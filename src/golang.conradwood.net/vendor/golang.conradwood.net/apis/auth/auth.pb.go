// Code generated by protoc-gen-go.
// source: protos/golang.conradwood.net/apis/auth/auth.proto
// DO NOT EDIT!

/*
Package auth is a generated protocol buffer package.

It is generated from these files:
	protos/golang.conradwood.net/apis/auth/auth.proto

It has these top-level messages:
	AuthResponse
	SignedAuthResponse
	SignedUser
	User
	LinkGroupOrganisation
	Organisation
	Group
	GroupList
	AddToGroupRequest
	RemoveFromGroupRequest
	ListGroupRequest
	UserListResponse
	UpdatePasswordRequest
	ElevateAccessRequest
	ForceUpdatePasswordRequest
	EditAnyUserRequest
	EditSelfRequest
	CreateGroup
	CreateGroupRequest
	CreateGroupResponse
	GetGroupRequest
	GetGroupResponse
	GroupDescriptionRequest
	CreateServiceRequest
	NewService
	ResetRequest
	ExpireTokenRequest
	VerifyEmailRequest
	VerifyEmailResponse
	GetTokenRequest
	TokenResponse
	UserList
	ByAbbrevRequest
	RemoteStoreRequest
	RemoteUserRequest
	RemoteUser
	RemoteUserDetail
	SudoRequest
	TokenCompromisedRequest
	NewToken
	VerifyRequest
	VerifyResponse
	ByIDRequest
	VerifyPasswordResponse
	CreateUserRequest
	ByEmailRequest
	UserEmailAddressList
	ListAllGroupsRequest
	NewPasswordResponse
	UserDef
	AddTokenRequest
	KeyResponse
	AuthenticatePasswordRequest
	AuthenticateTokenRequest
	UserDetail
	UserTokens
	GroupDB
	EmailVerifyPins
	SudoStatus
*/
package auth

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import common "golang.conradwood.net/apis/common"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type TokenType int32

const (
	TokenType_UNDEFINED TokenType = 0
	TokenType_PERMANENT TokenType = 1
	TokenType_SESSION   TokenType = 2
)

var TokenType_name = map[int32]string{
	0: "UNDEFINED",
	1: "PERMANENT",
	2: "SESSION",
}
var TokenType_value = map[string]int32{
	"UNDEFINED": 0,
	"PERMANENT": 1,
	"SESSION":   2,
}

func (x TokenType) String() string {
	return proto.EnumName(TokenType_name, int32(x))
}
func (TokenType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type AuthResponse struct {
	Valid         bool   `protobuf:"varint,1,opt,name=Valid" json:"Valid,omitempty"`
	PublicMessage string `protobuf:"bytes,2,opt,name=PublicMessage" json:"PublicMessage,omitempty"`
	LogMessage    string `protobuf:"bytes,3,opt,name=LogMessage" json:"LogMessage,omitempty"`
	User          *User  `protobuf:"bytes,4,opt,name=User" json:"User,omitempty"`
	Token         string `protobuf:"bytes,5,opt,name=Token" json:"Token,omitempty"`
}

func (m *AuthResponse) Reset()                    { *m = AuthResponse{} }
func (m *AuthResponse) String() string            { return proto.CompactTextString(m) }
func (*AuthResponse) ProtoMessage()               {}
func (*AuthResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *AuthResponse) GetValid() bool {
	if m != nil {
		return m.Valid
	}
	return false
}

func (m *AuthResponse) GetPublicMessage() string {
	if m != nil {
		return m.PublicMessage
	}
	return ""
}

func (m *AuthResponse) GetLogMessage() string {
	if m != nil {
		return m.LogMessage
	}
	return ""
}

func (m *AuthResponse) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *AuthResponse) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type SignedAuthResponse struct {
	Valid         bool        `protobuf:"varint,1,opt,name=Valid" json:"Valid,omitempty"`
	PublicMessage string      `protobuf:"bytes,2,opt,name=PublicMessage" json:"PublicMessage,omitempty"`
	LogMessage    string      `protobuf:"bytes,3,opt,name=LogMessage" json:"LogMessage,omitempty"`
	User          *SignedUser `protobuf:"bytes,4,opt,name=User" json:"User,omitempty"`
	Token         string      `protobuf:"bytes,5,opt,name=Token" json:"Token,omitempty"`
}

func (m *SignedAuthResponse) Reset()                    { *m = SignedAuthResponse{} }
func (m *SignedAuthResponse) String() string            { return proto.CompactTextString(m) }
func (*SignedAuthResponse) ProtoMessage()               {}
func (*SignedAuthResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *SignedAuthResponse) GetValid() bool {
	if m != nil {
		return m.Valid
	}
	return false
}

func (m *SignedAuthResponse) GetPublicMessage() string {
	if m != nil {
		return m.PublicMessage
	}
	return ""
}

func (m *SignedAuthResponse) GetLogMessage() string {
	if m != nil {
		return m.LogMessage
	}
	return ""
}

func (m *SignedAuthResponse) GetUser() *SignedUser {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *SignedAuthResponse) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

//
// this message contains a serialised proto and the signature over the serialised proto
// we are migrating towards this, as it allows us to update the proto in future without
// breaking backwards compatibility. The Signature within SignedUser.User is non-defined
// and may contain random bytes or 0. The only guarantee is that go-easyops can verify it as valid.
type SignedUser struct {
	User      []byte `protobuf:"bytes,1,opt,name=User,proto3" json:"User,omitempty"`
	Signature []byte `protobuf:"bytes,2,opt,name=Signature,proto3" json:"Signature,omitempty"`
}

func (m *SignedUser) Reset()                    { *m = SignedUser{} }
func (m *SignedUser) String() string            { return proto.CompactTextString(m) }
func (*SignedUser) ProtoMessage()               {}
func (*SignedUser) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *SignedUser) GetUser() []byte {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *SignedUser) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

//
// this message is cryptographically signed.
// Adding/removing fields must be done carefully so that the signature matches all fields.
// It also makes backwards compatibility difficult.
// read the code in auth-service/.../authbe/sign.go and go-easyops/.../auth/sign_verify.go
type User struct {
	ID             string   `protobuf:"bytes,1,opt,name=ID" json:"ID,omitempty"`
	Email          string   `protobuf:"bytes,2,opt,name=Email" json:"Email,omitempty"`
	FirstName      string   `protobuf:"bytes,3,opt,name=FirstName" json:"FirstName,omitempty"`
	LastName       string   `protobuf:"bytes,4,opt,name=LastName" json:"LastName,omitempty"`
	Password       string   `protobuf:"bytes,5,opt,name=Password" json:"Password,omitempty"`
	Groups         []*Group `protobuf:"bytes,6,rep,name=Groups" json:"Groups,omitempty"`
	Abbrev         string   `protobuf:"bytes,7,opt,name=Abbrev" json:"Abbrev,omitempty"`
	Active         bool     `protobuf:"varint,8,opt,name=Active" json:"Active,omitempty"`
	ServiceAccount bool     `protobuf:"varint,9,opt,name=ServiceAccount" json:"ServiceAccount,omitempty"`
	EmailVerified  bool     `protobuf:"varint,10,opt,name=EmailVerified" json:"EmailVerified,omitempty"`
	//
	// 0:not signed, otherwise version:
	// Version 2: ed25519 over ID, Email, FirstName, LastName, Active,Abbrev, GroupIDs, ServiceAccount, EmailVerified
	SignatureVersion uint32 `protobuf:"varint,11,opt,name=SignatureVersion" json:"SignatureVersion,omitempty"`
	SignedAt         uint32 `protobuf:"varint,12,opt,name=SignedAt" json:"SignedAt,omitempty"`
	SignatureID      []byte `protobuf:"bytes,13,opt,name=SignatureID,proto3" json:"SignatureID,omitempty"`
	SignatureFull    []byte `protobuf:"bytes,14,opt,name=SignatureFull,proto3" json:"SignatureFull,omitempty"`
	OrganisationID   string `protobuf:"bytes,15,opt,name=OrganisationID" json:"OrganisationID,omitempty"`
}

func (m *User) Reset()                    { *m = User{} }
func (m *User) String() string            { return proto.CompactTextString(m) }
func (*User) ProtoMessage()               {}
func (*User) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *User) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *User) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *User) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *User) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *User) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *User) GetGroups() []*Group {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *User) GetAbbrev() string {
	if m != nil {
		return m.Abbrev
	}
	return ""
}

func (m *User) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *User) GetServiceAccount() bool {
	if m != nil {
		return m.ServiceAccount
	}
	return false
}

func (m *User) GetEmailVerified() bool {
	if m != nil {
		return m.EmailVerified
	}
	return false
}

func (m *User) GetSignatureVersion() uint32 {
	if m != nil {
		return m.SignatureVersion
	}
	return 0
}

func (m *User) GetSignedAt() uint32 {
	if m != nil {
		return m.SignedAt
	}
	return 0
}

func (m *User) GetSignatureID() []byte {
	if m != nil {
		return m.SignatureID
	}
	return nil
}

func (m *User) GetSignatureFull() []byte {
	if m != nil {
		return m.SignatureFull
	}
	return nil
}

func (m *User) GetOrganisationID() string {
	if m != nil {
		return m.OrganisationID
	}
	return ""
}

type LinkGroupOrganisation struct {
	ID      uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	OrgID   uint64 `protobuf:"varint,2,opt,name=OrgID" json:"OrgID,omitempty"`
	GroupID uint64 `protobuf:"varint,3,opt,name=GroupID" json:"GroupID,omitempty"`
}

func (m *LinkGroupOrganisation) Reset()                    { *m = LinkGroupOrganisation{} }
func (m *LinkGroupOrganisation) String() string            { return proto.CompactTextString(m) }
func (*LinkGroupOrganisation) ProtoMessage()               {}
func (*LinkGroupOrganisation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *LinkGroupOrganisation) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *LinkGroupOrganisation) GetOrgID() uint64 {
	if m != nil {
		return m.OrgID
	}
	return 0
}

func (m *LinkGroupOrganisation) GetGroupID() uint64 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

type Organisation struct {
	ID   uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Name string `protobuf:"bytes,2,opt,name=Name" json:"Name,omitempty"`
}

func (m *Organisation) Reset()                    { *m = Organisation{} }
func (m *Organisation) String() string            { return proto.CompactTextString(m) }
func (*Organisation) ProtoMessage()               {}
func (*Organisation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Organisation) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Organisation) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type Group struct {
	ID   string `protobuf:"bytes,1,opt,name=ID" json:"ID,omitempty"`
	Name string `protobuf:"bytes,2,opt,name=Name" json:"Name,omitempty"`
	// a free text field describing the usage of this group
	Description string `protobuf:"bytes,3,opt,name=Description" json:"Description,omitempty"`
}

func (m *Group) Reset()                    { *m = Group{} }
func (m *Group) String() string            { return proto.CompactTextString(m) }
func (*Group) ProtoMessage()               {}
func (*Group) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Group) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Group) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Group) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

type GroupList struct {
	Groups []*Group `protobuf:"bytes,1,rep,name=Groups" json:"Groups,omitempty"`
}

func (m *GroupList) Reset()                    { *m = GroupList{} }
func (m *GroupList) String() string            { return proto.CompactTextString(m) }
func (*GroupList) ProtoMessage()               {}
func (*GroupList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *GroupList) GetGroups() []*Group {
	if m != nil {
		return m.Groups
	}
	return nil
}

type AddToGroupRequest struct {
	UserID  string `protobuf:"bytes,1,opt,name=UserID" json:"UserID,omitempty"`
	GroupID string `protobuf:"bytes,2,opt,name=GroupID" json:"GroupID,omitempty"`
}

func (m *AddToGroupRequest) Reset()                    { *m = AddToGroupRequest{} }
func (m *AddToGroupRequest) String() string            { return proto.CompactTextString(m) }
func (*AddToGroupRequest) ProtoMessage()               {}
func (*AddToGroupRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *AddToGroupRequest) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *AddToGroupRequest) GetGroupID() string {
	if m != nil {
		return m.GroupID
	}
	return ""
}

type RemoveFromGroupRequest struct {
	UserID  string `protobuf:"bytes,1,opt,name=UserID" json:"UserID,omitempty"`
	GroupID string `protobuf:"bytes,2,opt,name=GroupID" json:"GroupID,omitempty"`
}

func (m *RemoveFromGroupRequest) Reset()                    { *m = RemoveFromGroupRequest{} }
func (m *RemoveFromGroupRequest) String() string            { return proto.CompactTextString(m) }
func (*RemoveFromGroupRequest) ProtoMessage()               {}
func (*RemoveFromGroupRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *RemoveFromGroupRequest) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *RemoveFromGroupRequest) GetGroupID() string {
	if m != nil {
		return m.GroupID
	}
	return ""
}

type ListGroupRequest struct {
	GroupID              string `protobuf:"bytes,1,opt,name=GroupID" json:"GroupID,omitempty"`
	IncludeInactiveUsers bool   `protobuf:"varint,2,opt,name=IncludeInactiveUsers" json:"IncludeInactiveUsers,omitempty"`
}

func (m *ListGroupRequest) Reset()                    { *m = ListGroupRequest{} }
func (m *ListGroupRequest) String() string            { return proto.CompactTextString(m) }
func (*ListGroupRequest) ProtoMessage()               {}
func (*ListGroupRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *ListGroupRequest) GetGroupID() string {
	if m != nil {
		return m.GroupID
	}
	return ""
}

func (m *ListGroupRequest) GetIncludeInactiveUsers() bool {
	if m != nil {
		return m.IncludeInactiveUsers
	}
	return false
}

type UserListResponse struct {
	Users []*User `protobuf:"bytes,1,rep,name=Users" json:"Users,omitempty"`
}

func (m *UserListResponse) Reset()                    { *m = UserListResponse{} }
func (m *UserListResponse) String() string            { return proto.CompactTextString(m) }
func (*UserListResponse) ProtoMessage()               {}
func (*UserListResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *UserListResponse) GetUsers() []*User {
	if m != nil {
		return m.Users
	}
	return nil
}

type UpdatePasswordRequest struct {
	NewPassword string `protobuf:"bytes,1,opt,name=NewPassword" json:"NewPassword,omitempty"`
}

func (m *UpdatePasswordRequest) Reset()                    { *m = UpdatePasswordRequest{} }
func (m *UpdatePasswordRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdatePasswordRequest) ProtoMessage()               {}
func (*UpdatePasswordRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *UpdatePasswordRequest) GetNewPassword() string {
	if m != nil {
		return m.NewPassword
	}
	return ""
}

type ElevateAccessRequest struct {
	// groupids I want to be part of. If this contains existing groups, the call will be rejected.
	GroupIDs []string `protobuf:"bytes,1,rep,name=GroupIDs" json:"GroupIDs,omitempty"`
	// after this many seconds have elapsed the access will be downgraded again
	DurationSecs uint32 `protobuf:"varint,2,opt,name=DurationSecs" json:"DurationSecs,omitempty"`
}

func (m *ElevateAccessRequest) Reset()                    { *m = ElevateAccessRequest{} }
func (m *ElevateAccessRequest) String() string            { return proto.CompactTextString(m) }
func (*ElevateAccessRequest) ProtoMessage()               {}
func (*ElevateAccessRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *ElevateAccessRequest) GetGroupIDs() []string {
	if m != nil {
		return m.GroupIDs
	}
	return nil
}

func (m *ElevateAccessRequest) GetDurationSecs() uint32 {
	if m != nil {
		return m.DurationSecs
	}
	return 0
}

type ForceUpdatePasswordRequest struct {
	UserID      string `protobuf:"bytes,1,opt,name=UserID" json:"UserID,omitempty"`
	NewPassword string `protobuf:"bytes,2,opt,name=NewPassword" json:"NewPassword,omitempty"`
}

func (m *ForceUpdatePasswordRequest) Reset()                    { *m = ForceUpdatePasswordRequest{} }
func (m *ForceUpdatePasswordRequest) String() string            { return proto.CompactTextString(m) }
func (*ForceUpdatePasswordRequest) ProtoMessage()               {}
func (*ForceUpdatePasswordRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *ForceUpdatePasswordRequest) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *ForceUpdatePasswordRequest) GetNewPassword() string {
	if m != nil {
		return m.NewPassword
	}
	return ""
}

// authorised by "root_auth_admin" group members
type EditAnyUserRequest struct {
	UserID    string `protobuf:"bytes,1,opt,name=UserID" json:"UserID,omitempty"`
	FirstName string `protobuf:"bytes,2,opt,name=FirstName" json:"FirstName,omitempty"`
	LastName  string `protobuf:"bytes,3,opt,name=LastName" json:"LastName,omitempty"`
}

func (m *EditAnyUserRequest) Reset()                    { *m = EditAnyUserRequest{} }
func (m *EditAnyUserRequest) String() string            { return proto.CompactTextString(m) }
func (*EditAnyUserRequest) ProtoMessage()               {}
func (*EditAnyUserRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *EditAnyUserRequest) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *EditAnyUserRequest) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *EditAnyUserRequest) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

type EditSelfRequest struct {
	FirstName string `protobuf:"bytes,1,opt,name=FirstName" json:"FirstName,omitempty"`
	LastName  string `protobuf:"bytes,2,opt,name=LastName" json:"LastName,omitempty"`
}

func (m *EditSelfRequest) Reset()                    { *m = EditSelfRequest{} }
func (m *EditSelfRequest) String() string            { return proto.CompactTextString(m) }
func (*EditSelfRequest) ProtoMessage()               {}
func (*EditSelfRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *EditSelfRequest) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *EditSelfRequest) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

// CreateGroup holds the details required for creating a group
type CreateGroup struct {
	Name        string `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
	Description string `protobuf:"bytes,4,opt,name=Description" json:"Description,omitempty"`
}

func (m *CreateGroup) Reset()                    { *m = CreateGroup{} }
func (m *CreateGroup) String() string            { return proto.CompactTextString(m) }
func (*CreateGroup) ProtoMessage()               {}
func (*CreateGroup) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *CreateGroup) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreateGroup) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// CreateGroupRequest holds the details of a request to create a group
type CreateGroupRequest struct {
	CreateGroup *CreateGroup `protobuf:"bytes,1,opt,name=CreateGroup" json:"CreateGroup,omitempty"`
}

func (m *CreateGroupRequest) Reset()                    { *m = CreateGroupRequest{} }
func (m *CreateGroupRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateGroupRequest) ProtoMessage()               {}
func (*CreateGroupRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *CreateGroupRequest) GetCreateGroup() *CreateGroup {
	if m != nil {
		return m.CreateGroup
	}
	return nil
}

// CreateGroupResponse returns the details of a group that has been created
type CreateGroupResponse struct {
	Group *Group `protobuf:"bytes,1,opt,name=Group" json:"Group,omitempty"`
}

func (m *CreateGroupResponse) Reset()                    { *m = CreateGroupResponse{} }
func (m *CreateGroupResponse) String() string            { return proto.CompactTextString(m) }
func (*CreateGroupResponse) ProtoMessage()               {}
func (*CreateGroupResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *CreateGroupResponse) GetGroup() *Group {
	if m != nil {
		return m.Group
	}
	return nil
}

type GetGroupRequest struct {
	ID string `protobuf:"bytes,1,opt,name=ID" json:"ID,omitempty"`
}

func (m *GetGroupRequest) Reset()                    { *m = GetGroupRequest{} }
func (m *GetGroupRequest) String() string            { return proto.CompactTextString(m) }
func (*GetGroupRequest) ProtoMessage()               {}
func (*GetGroupRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *GetGroupRequest) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

type GetGroupResponse struct {
	Group *Group `protobuf:"bytes,1,opt,name=Group" json:"Group,omitempty"`
}

func (m *GetGroupResponse) Reset()                    { *m = GetGroupResponse{} }
func (m *GetGroupResponse) String() string            { return proto.CompactTextString(m) }
func (*GetGroupResponse) ProtoMessage()               {}
func (*GetGroupResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *GetGroupResponse) GetGroup() *Group {
	if m != nil {
		return m.Group
	}
	return nil
}

type GroupDescriptionRequest struct {
	GroupID     string `protobuf:"bytes,1,opt,name=GroupID" json:"GroupID,omitempty"`
	Description string `protobuf:"bytes,2,opt,name=Description" json:"Description,omitempty"`
}

func (m *GroupDescriptionRequest) Reset()                    { *m = GroupDescriptionRequest{} }
func (m *GroupDescriptionRequest) String() string            { return proto.CompactTextString(m) }
func (*GroupDescriptionRequest) ProtoMessage()               {}
func (*GroupDescriptionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *GroupDescriptionRequest) GetGroupID() string {
	if m != nil {
		return m.GroupID
	}
	return ""
}

func (m *GroupDescriptionRequest) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

type CreateServiceRequest struct {
	ServiceName string `protobuf:"bytes,1,opt,name=ServiceName" json:"ServiceName,omitempty"`
	Token       string `protobuf:"bytes,2,opt,name=Token" json:"Token,omitempty"`
}

func (m *CreateServiceRequest) Reset()                    { *m = CreateServiceRequest{} }
func (m *CreateServiceRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateServiceRequest) ProtoMessage()               {}
func (*CreateServiceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *CreateServiceRequest) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

func (m *CreateServiceRequest) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type NewService struct {
	User  *User  `protobuf:"bytes,1,opt,name=User" json:"User,omitempty"`
	Token string `protobuf:"bytes,2,opt,name=Token" json:"Token,omitempty"`
}

func (m *NewService) Reset()                    { *m = NewService{} }
func (m *NewService) String() string            { return proto.CompactTextString(m) }
func (*NewService) ProtoMessage()               {}
func (*NewService) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *NewService) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *NewService) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type ResetRequest struct {
	Email string `protobuf:"bytes,1,opt,name=Email" json:"Email,omitempty"`
}

func (m *ResetRequest) Reset()                    { *m = ResetRequest{} }
func (m *ResetRequest) String() string            { return proto.CompactTextString(m) }
func (*ResetRequest) ProtoMessage()               {}
func (*ResetRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *ResetRequest) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

type ExpireTokenRequest struct {
	Token string `protobuf:"bytes,1,opt,name=Token" json:"Token,omitempty"`
}

func (m *ExpireTokenRequest) Reset()                    { *m = ExpireTokenRequest{} }
func (m *ExpireTokenRequest) String() string            { return proto.CompactTextString(m) }
func (*ExpireTokenRequest) ProtoMessage()               {}
func (*ExpireTokenRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *ExpireTokenRequest) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type VerifyEmailRequest struct {
	Pin string `protobuf:"bytes,1,opt,name=Pin" json:"Pin,omitempty"`
}

func (m *VerifyEmailRequest) Reset()                    { *m = VerifyEmailRequest{} }
func (m *VerifyEmailRequest) String() string            { return proto.CompactTextString(m) }
func (*VerifyEmailRequest) ProtoMessage()               {}
func (*VerifyEmailRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *VerifyEmailRequest) GetPin() string {
	if m != nil {
		return m.Pin
	}
	return ""
}

type VerifyEmailResponse struct {
	Verified bool `protobuf:"varint,1,opt,name=Verified" json:"Verified,omitempty"`
}

func (m *VerifyEmailResponse) Reset()                    { *m = VerifyEmailResponse{} }
func (m *VerifyEmailResponse) String() string            { return proto.CompactTextString(m) }
func (*VerifyEmailResponse) ProtoMessage()               {}
func (*VerifyEmailResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *VerifyEmailResponse) GetVerified() bool {
	if m != nil {
		return m.Verified
	}
	return false
}

type GetTokenRequest struct {
	DurationSecs uint64 `protobuf:"varint,1,opt,name=DurationSecs" json:"DurationSecs,omitempty"`
}

func (m *GetTokenRequest) Reset()                    { *m = GetTokenRequest{} }
func (m *GetTokenRequest) String() string            { return proto.CompactTextString(m) }
func (*GetTokenRequest) ProtoMessage()               {}
func (*GetTokenRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *GetTokenRequest) GetDurationSecs() uint64 {
	if m != nil {
		return m.DurationSecs
	}
	return 0
}

type TokenResponse struct {
	Expiry uint32 `protobuf:"varint,1,opt,name=Expiry" json:"Expiry,omitempty"`
	Token  string `protobuf:"bytes,2,opt,name=Token" json:"Token,omitempty"`
}

func (m *TokenResponse) Reset()                    { *m = TokenResponse{} }
func (m *TokenResponse) String() string            { return proto.CompactTextString(m) }
func (*TokenResponse) ProtoMessage()               {}
func (*TokenResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

func (m *TokenResponse) GetExpiry() uint32 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

func (m *TokenResponse) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type UserList struct {
	Users []*SignedUser `protobuf:"bytes,1,rep,name=Users" json:"Users,omitempty"`
}

func (m *UserList) Reset()                    { *m = UserList{} }
func (m *UserList) String() string            { return proto.CompactTextString(m) }
func (*UserList) ProtoMessage()               {}
func (*UserList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31} }

func (m *UserList) GetUsers() []*SignedUser {
	if m != nil {
		return m.Users
	}
	return nil
}

type ByAbbrevRequest struct {
	Abbrev string `protobuf:"bytes,1,opt,name=Abbrev" json:"Abbrev,omitempty"`
}

func (m *ByAbbrevRequest) Reset()                    { *m = ByAbbrevRequest{} }
func (m *ByAbbrevRequest) String() string            { return proto.CompactTextString(m) }
func (*ByAbbrevRequest) ProtoMessage()               {}
func (*ByAbbrevRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32} }

func (m *ByAbbrevRequest) GetAbbrev() string {
	if m != nil {
		return m.Abbrev
	}
	return ""
}

type RemoteStoreRequest struct {
	UserID       string `protobuf:"bytes,1,opt,name=UserID" json:"UserID,omitempty"`
	OurToken     string `protobuf:"bytes,2,opt,name=OurToken" json:"OurToken,omitempty"`
	RemoteUserID string `protobuf:"bytes,3,opt,name=RemoteUserID" json:"RemoteUserID,omitempty"`
	Provider     string `protobuf:"bytes,4,opt,name=Provider" json:"Provider,omitempty"`
}

func (m *RemoteStoreRequest) Reset()                    { *m = RemoteStoreRequest{} }
func (m *RemoteStoreRequest) String() string            { return proto.CompactTextString(m) }
func (*RemoteStoreRequest) ProtoMessage()               {}
func (*RemoteStoreRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33} }

func (m *RemoteStoreRequest) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *RemoteStoreRequest) GetOurToken() string {
	if m != nil {
		return m.OurToken
	}
	return ""
}

func (m *RemoteStoreRequest) GetRemoteUserID() string {
	if m != nil {
		return m.RemoteUserID
	}
	return ""
}

func (m *RemoteStoreRequest) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

type RemoteUserRequest struct {
	OurToken string `protobuf:"bytes,1,opt,name=OurToken" json:"OurToken,omitempty"`
}

func (m *RemoteUserRequest) Reset()                    { *m = RemoteUserRequest{} }
func (m *RemoteUserRequest) String() string            { return proto.CompactTextString(m) }
func (*RemoteUserRequest) ProtoMessage()               {}
func (*RemoteUserRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{34} }

func (m *RemoteUserRequest) GetOurToken() string {
	if m != nil {
		return m.OurToken
	}
	return ""
}

type RemoteUser struct {
	User    *User               `protobuf:"bytes,1,opt,name=User" json:"User,omitempty"`
	Details []*RemoteUserDetail `protobuf:"bytes,2,rep,name=Details" json:"Details,omitempty"`
}

func (m *RemoteUser) Reset()                    { *m = RemoteUser{} }
func (m *RemoteUser) String() string            { return proto.CompactTextString(m) }
func (*RemoteUser) ProtoMessage()               {}
func (*RemoteUser) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{35} }

func (m *RemoteUser) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *RemoteUser) GetDetails() []*RemoteUserDetail {
	if m != nil {
		return m.Details
	}
	return nil
}

type RemoteUserDetail struct {
	ID           uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	UserID       string `protobuf:"bytes,2,opt,name=UserID" json:"UserID,omitempty"`
	Provider     string `protobuf:"bytes,3,opt,name=Provider" json:"Provider,omitempty"`
	OurToken     string `protobuf:"bytes,4,opt,name=OurToken" json:"OurToken,omitempty"`
	Created      uint32 `protobuf:"varint,5,opt,name=Created" json:"Created,omitempty"`
	RemoteUserID string `protobuf:"bytes,6,opt,name=RemoteUserID" json:"RemoteUserID,omitempty"`
}

func (m *RemoteUserDetail) Reset()                    { *m = RemoteUserDetail{} }
func (m *RemoteUserDetail) String() string            { return proto.CompactTextString(m) }
func (*RemoteUserDetail) ProtoMessage()               {}
func (*RemoteUserDetail) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{36} }

func (m *RemoteUserDetail) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *RemoteUserDetail) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *RemoteUserDetail) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *RemoteUserDetail) GetOurToken() string {
	if m != nil {
		return m.OurToken
	}
	return ""
}

func (m *RemoteUserDetail) GetCreated() uint32 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *RemoteUserDetail) GetRemoteUserID() string {
	if m != nil {
		return m.RemoteUserID
	}
	return ""
}

type SudoRequest struct {
	UserID string `protobuf:"bytes,1,opt,name=UserID" json:"UserID,omitempty"`
}

func (m *SudoRequest) Reset()                    { *m = SudoRequest{} }
func (m *SudoRequest) String() string            { return proto.CompactTextString(m) }
func (*SudoRequest) ProtoMessage()               {}
func (*SudoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{37} }

func (m *SudoRequest) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

type TokenCompromisedRequest struct {
	Token string `protobuf:"bytes,1,opt,name=Token" json:"Token,omitempty"`
}

func (m *TokenCompromisedRequest) Reset()                    { *m = TokenCompromisedRequest{} }
func (m *TokenCompromisedRequest) String() string            { return proto.CompactTextString(m) }
func (*TokenCompromisedRequest) ProtoMessage()               {}
func (*TokenCompromisedRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{38} }

func (m *TokenCompromisedRequest) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type NewToken struct {
	Token string `protobuf:"bytes,1,opt,name=Token" json:"Token,omitempty"`
}

func (m *NewToken) Reset()                    { *m = NewToken{} }
func (m *NewToken) String() string            { return proto.CompactTextString(m) }
func (*NewToken) ProtoMessage()               {}
func (*NewToken) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{39} }

func (m *NewToken) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type VerifyRequest struct {
	Token string `protobuf:"bytes,1,opt,name=Token" json:"Token,omitempty"`
}

func (m *VerifyRequest) Reset()                    { *m = VerifyRequest{} }
func (m *VerifyRequest) String() string            { return proto.CompactTextString(m) }
func (*VerifyRequest) ProtoMessage()               {}
func (*VerifyRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{40} }

func (m *VerifyRequest) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type VerifyResponse struct {
	Valid bool  `protobuf:"varint,1,opt,name=Valid" json:"Valid,omitempty"`
	User  *User `protobuf:"bytes,2,opt,name=User" json:"User,omitempty"`
}

func (m *VerifyResponse) Reset()                    { *m = VerifyResponse{} }
func (m *VerifyResponse) String() string            { return proto.CompactTextString(m) }
func (*VerifyResponse) ProtoMessage()               {}
func (*VerifyResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{41} }

func (m *VerifyResponse) GetValid() bool {
	if m != nil {
		return m.Valid
	}
	return false
}

func (m *VerifyResponse) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

type ByIDRequest struct {
	UserID string `protobuf:"bytes,1,opt,name=UserID" json:"UserID,omitempty"`
}

func (m *ByIDRequest) Reset()                    { *m = ByIDRequest{} }
func (m *ByIDRequest) String() string            { return proto.CompactTextString(m) }
func (*ByIDRequest) ProtoMessage()               {}
func (*ByIDRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{42} }

func (m *ByIDRequest) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

type VerifyPasswordResponse struct {
	User  *User  `protobuf:"bytes,1,opt,name=User" json:"User,omitempty"`
	Token string `protobuf:"bytes,2,opt,name=Token" json:"Token,omitempty"`
}

func (m *VerifyPasswordResponse) Reset()                    { *m = VerifyPasswordResponse{} }
func (m *VerifyPasswordResponse) String() string            { return proto.CompactTextString(m) }
func (*VerifyPasswordResponse) ProtoMessage()               {}
func (*VerifyPasswordResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{43} }

func (m *VerifyPasswordResponse) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *VerifyPasswordResponse) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type CreateUserRequest struct {
	Email         string `protobuf:"bytes,1,opt,name=Email" json:"Email,omitempty"`
	FirstName     string `protobuf:"bytes,2,opt,name=FirstName" json:"FirstName,omitempty"`
	LastName      string `protobuf:"bytes,3,opt,name=LastName" json:"LastName,omitempty"`
	Password      string `protobuf:"bytes,4,opt,name=Password" json:"Password,omitempty"`
	Abbrev        string `protobuf:"bytes,5,opt,name=Abbrev" json:"Abbrev,omitempty"`
	EmailVerified bool   `protobuf:"varint,6,opt,name=EmailVerified" json:"EmailVerified,omitempty"`
}

func (m *CreateUserRequest) Reset()                    { *m = CreateUserRequest{} }
func (m *CreateUserRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateUserRequest) ProtoMessage()               {}
func (*CreateUserRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{44} }

func (m *CreateUserRequest) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *CreateUserRequest) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *CreateUserRequest) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *CreateUserRequest) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *CreateUserRequest) GetAbbrev() string {
	if m != nil {
		return m.Abbrev
	}
	return ""
}

func (m *CreateUserRequest) GetEmailVerified() bool {
	if m != nil {
		return m.EmailVerified
	}
	return false
}

type ByEmailRequest struct {
	Email string `protobuf:"bytes,1,opt,name=Email" json:"Email,omitempty"`
}

func (m *ByEmailRequest) Reset()                    { *m = ByEmailRequest{} }
func (m *ByEmailRequest) String() string            { return proto.CompactTextString(m) }
func (*ByEmailRequest) ProtoMessage()               {}
func (*ByEmailRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{45} }

func (m *ByEmailRequest) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

type UserEmailAddressList struct {
	Emails []string `protobuf:"bytes,1,rep,name=Emails" json:"Emails,omitempty"`
}

func (m *UserEmailAddressList) Reset()                    { *m = UserEmailAddressList{} }
func (m *UserEmailAddressList) String() string            { return proto.CompactTextString(m) }
func (*UserEmailAddressList) ProtoMessage()               {}
func (*UserEmailAddressList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{46} }

func (m *UserEmailAddressList) GetEmails() []string {
	if m != nil {
		return m.Emails
	}
	return nil
}

type ListAllGroupsRequest struct {
}

func (m *ListAllGroupsRequest) Reset()                    { *m = ListAllGroupsRequest{} }
func (m *ListAllGroupsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListAllGroupsRequest) ProtoMessage()               {}
func (*ListAllGroupsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{47} }

type NewPasswordResponse struct {
	Password string `protobuf:"bytes,1,opt,name=Password" json:"Password,omitempty"`
}

func (m *NewPasswordResponse) Reset()                    { *m = NewPasswordResponse{} }
func (m *NewPasswordResponse) String() string            { return proto.CompactTextString(m) }
func (*NewPasswordResponse) ProtoMessage()               {}
func (*NewPasswordResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{48} }

func (m *NewPasswordResponse) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type UserDef struct {
	UserID string `protobuf:"bytes,1,opt,name=UserID" json:"UserID,omitempty"`
}

func (m *UserDef) Reset()                    { *m = UserDef{} }
func (m *UserDef) String() string            { return proto.CompactTextString(m) }
func (*UserDef) ProtoMessage()               {}
func (*UserDef) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{49} }

func (m *UserDef) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

type AddTokenRequest struct {
	UserID          string `protobuf:"bytes,1,opt,name=UserID" json:"UserID,omitempty"`
	Token           string `protobuf:"bytes,2,opt,name=Token" json:"Token,omitempty"`
	ExpiryTimestamp uint32 `protobuf:"varint,3,opt,name=ExpiryTimestamp" json:"ExpiryTimestamp,omitempty"`
}

func (m *AddTokenRequest) Reset()                    { *m = AddTokenRequest{} }
func (m *AddTokenRequest) String() string            { return proto.CompactTextString(m) }
func (*AddTokenRequest) ProtoMessage()               {}
func (*AddTokenRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{50} }

func (m *AddTokenRequest) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *AddTokenRequest) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *AddTokenRequest) GetExpiryTimestamp() uint32 {
	if m != nil {
		return m.ExpiryTimestamp
	}
	return 0
}

type KeyResponse struct {
	Key       []byte `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	CloudName string `protobuf:"bytes,2,opt,name=CloudName" json:"CloudName,omitempty"`
}

func (m *KeyResponse) Reset()                    { *m = KeyResponse{} }
func (m *KeyResponse) String() string            { return proto.CompactTextString(m) }
func (*KeyResponse) ProtoMessage()               {}
func (*KeyResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{51} }

func (m *KeyResponse) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *KeyResponse) GetCloudName() string {
	if m != nil {
		return m.CloudName
	}
	return ""
}

type AuthenticatePasswordRequest struct {
	Email    string `protobuf:"bytes,1,opt,name=Email" json:"Email,omitempty"`
	Password string `protobuf:"bytes,2,opt,name=Password" json:"Password,omitempty"`
}

func (m *AuthenticatePasswordRequest) Reset()                    { *m = AuthenticatePasswordRequest{} }
func (m *AuthenticatePasswordRequest) String() string            { return proto.CompactTextString(m) }
func (*AuthenticatePasswordRequest) ProtoMessage()               {}
func (*AuthenticatePasswordRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{52} }

func (m *AuthenticatePasswordRequest) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *AuthenticatePasswordRequest) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type AuthenticateTokenRequest struct {
	Token string `protobuf:"bytes,1,opt,name=Token" json:"Token,omitempty"`
}

func (m *AuthenticateTokenRequest) Reset()                    { *m = AuthenticateTokenRequest{} }
func (m *AuthenticateTokenRequest) String() string            { return proto.CompactTextString(m) }
func (*AuthenticateTokenRequest) ProtoMessage()               {}
func (*AuthenticateTokenRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{53} }

func (m *AuthenticateTokenRequest) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

//
// id            | bigint                      |           | not null |
// email         | character varying(1000)     |           | not null |
// emailverified | integer                     |           | not null |
// firstname     | character varying(1000)     |           | not null |
// lastname      | character varying(1000)     |           | not null |
// password      | character varying(1000)     |           | not null |
// created       | timestamp without time zone |           | not null |
// lastmodified  | timestamp without time zone |           | not null |
// creator_id    | bigint                      |           | not null |
// modifiedby_id | bigint                      |           | not null |
// admin         | boolean                     |           | not null |
type UserDetail struct {
	ID            uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Email         string `protobuf:"bytes,2,opt,name=Email" json:"Email,omitempty"`
	FirstName     string `protobuf:"bytes,3,opt,name=FirstName" json:"FirstName,omitempty"`
	LastName      string `protobuf:"bytes,4,opt,name=LastName" json:"LastName,omitempty"`
	Password      string `protobuf:"bytes,5,opt,name=Password" json:"Password,omitempty"`
	Admin         bool   `protobuf:"varint,6,opt,name=Admin" json:"Admin,omitempty"`
	EmailVerified uint32 `protobuf:"varint,7,opt,name=EmailVerified" json:"EmailVerified,omitempty"`
}

func (m *UserDetail) Reset()                    { *m = UserDetail{} }
func (m *UserDetail) String() string            { return proto.CompactTextString(m) }
func (*UserDetail) ProtoMessage()               {}
func (*UserDetail) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{54} }

func (m *UserDetail) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *UserDetail) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *UserDetail) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *UserDetail) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *UserDetail) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *UserDetail) GetAdmin() bool {
	if m != nil {
		return m.Admin
	}
	return false
}

func (m *UserDetail) GetEmailVerified() uint32 {
	if m != nil {
		return m.EmailVerified
	}
	return 0
}

type UserTokens struct {
	ID        uint64    `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	UserID    uint64    `protobuf:"varint,2,opt,name=UserID" json:"UserID,omitempty"`
	Token     string    `protobuf:"bytes,3,opt,name=Token" json:"Token,omitempty"`
	Created   uint32    `protobuf:"varint,4,opt,name=Created" json:"Created,omitempty"`
	Expiry    uint32    `protobuf:"varint,5,opt,name=Expiry" json:"Expiry,omitempty"`
	TokenType TokenType `protobuf:"varint,6,opt,name=TokenType,enum=auth.TokenType" json:"TokenType,omitempty"`
}

func (m *UserTokens) Reset()                    { *m = UserTokens{} }
func (m *UserTokens) String() string            { return proto.CompactTextString(m) }
func (*UserTokens) ProtoMessage()               {}
func (*UserTokens) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{55} }

func (m *UserTokens) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *UserTokens) GetUserID() uint64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UserTokens) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *UserTokens) GetCreated() uint32 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *UserTokens) GetExpiry() uint32 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

func (m *UserTokens) GetTokenType() TokenType {
	if m != nil {
		return m.TokenType
	}
	return TokenType_UNDEFINED
}

type GroupDB struct {
	ID          uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Name        string `protobuf:"bytes,2,opt,name=Name" json:"Name,omitempty"`
	Description string `protobuf:"bytes,3,opt,name=Description" json:"Description,omitempty"`
}

func (m *GroupDB) Reset()                    { *m = GroupDB{} }
func (m *GroupDB) String() string            { return proto.CompactTextString(m) }
func (*GroupDB) ProtoMessage()               {}
func (*GroupDB) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{56} }

func (m *GroupDB) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *GroupDB) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GroupDB) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

type EmailVerifyPins struct {
	ID       uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	UserID   uint64 `protobuf:"varint,2,opt,name=UserID" json:"UserID,omitempty"`
	Pin      string `protobuf:"bytes,3,opt,name=Pin" json:"Pin,omitempty"`
	Created  uint64 `protobuf:"varint,4,opt,name=Created" json:"Created,omitempty"`
	Accepted uint64 `protobuf:"varint,5,opt,name=Accepted" json:"Accepted,omitempty"`
}

func (m *EmailVerifyPins) Reset()                    { *m = EmailVerifyPins{} }
func (m *EmailVerifyPins) String() string            { return proto.CompactTextString(m) }
func (*EmailVerifyPins) ProtoMessage()               {}
func (*EmailVerifyPins) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{57} }

func (m *EmailVerifyPins) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *EmailVerifyPins) GetUserID() uint64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *EmailVerifyPins) GetPin() string {
	if m != nil {
		return m.Pin
	}
	return ""
}

func (m *EmailVerifyPins) GetCreated() uint64 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *EmailVerifyPins) GetAccepted() uint64 {
	if m != nil {
		return m.Accepted
	}
	return 0
}

type SudoStatus struct {
	ID uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	// which user has sudoed
	UserID uint64 `protobuf:"varint,2,opt,name=UserID" json:"UserID,omitempty"`
	// to which group? typcially root
	GroupID string `protobuf:"bytes,3,opt,name=GroupID" json:"GroupID,omitempty"`
	// for how long?
	Expiry uint32 `protobuf:"varint,4,opt,name=Expiry" json:"Expiry,omitempty"`
}

func (m *SudoStatus) Reset()                    { *m = SudoStatus{} }
func (m *SudoStatus) String() string            { return proto.CompactTextString(m) }
func (*SudoStatus) ProtoMessage()               {}
func (*SudoStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{58} }

func (m *SudoStatus) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *SudoStatus) GetUserID() uint64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *SudoStatus) GetGroupID() string {
	if m != nil {
		return m.GroupID
	}
	return ""
}

func (m *SudoStatus) GetExpiry() uint32 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

func init() {
	proto.RegisterType((*AuthResponse)(nil), "auth.AuthResponse")
	proto.RegisterType((*SignedAuthResponse)(nil), "auth.SignedAuthResponse")
	proto.RegisterType((*SignedUser)(nil), "auth.SignedUser")
	proto.RegisterType((*User)(nil), "auth.User")
	proto.RegisterType((*LinkGroupOrganisation)(nil), "auth.LinkGroupOrganisation")
	proto.RegisterType((*Organisation)(nil), "auth.Organisation")
	proto.RegisterType((*Group)(nil), "auth.Group")
	proto.RegisterType((*GroupList)(nil), "auth.GroupList")
	proto.RegisterType((*AddToGroupRequest)(nil), "auth.AddToGroupRequest")
	proto.RegisterType((*RemoveFromGroupRequest)(nil), "auth.RemoveFromGroupRequest")
	proto.RegisterType((*ListGroupRequest)(nil), "auth.ListGroupRequest")
	proto.RegisterType((*UserListResponse)(nil), "auth.UserListResponse")
	proto.RegisterType((*UpdatePasswordRequest)(nil), "auth.UpdatePasswordRequest")
	proto.RegisterType((*ElevateAccessRequest)(nil), "auth.ElevateAccessRequest")
	proto.RegisterType((*ForceUpdatePasswordRequest)(nil), "auth.ForceUpdatePasswordRequest")
	proto.RegisterType((*EditAnyUserRequest)(nil), "auth.EditAnyUserRequest")
	proto.RegisterType((*EditSelfRequest)(nil), "auth.EditSelfRequest")
	proto.RegisterType((*CreateGroup)(nil), "auth.CreateGroup")
	proto.RegisterType((*CreateGroupRequest)(nil), "auth.CreateGroupRequest")
	proto.RegisterType((*CreateGroupResponse)(nil), "auth.CreateGroupResponse")
	proto.RegisterType((*GetGroupRequest)(nil), "auth.GetGroupRequest")
	proto.RegisterType((*GetGroupResponse)(nil), "auth.GetGroupResponse")
	proto.RegisterType((*GroupDescriptionRequest)(nil), "auth.GroupDescriptionRequest")
	proto.RegisterType((*CreateServiceRequest)(nil), "auth.CreateServiceRequest")
	proto.RegisterType((*NewService)(nil), "auth.NewService")
	proto.RegisterType((*ResetRequest)(nil), "auth.ResetRequest")
	proto.RegisterType((*ExpireTokenRequest)(nil), "auth.ExpireTokenRequest")
	proto.RegisterType((*VerifyEmailRequest)(nil), "auth.VerifyEmailRequest")
	proto.RegisterType((*VerifyEmailResponse)(nil), "auth.VerifyEmailResponse")
	proto.RegisterType((*GetTokenRequest)(nil), "auth.GetTokenRequest")
	proto.RegisterType((*TokenResponse)(nil), "auth.TokenResponse")
	proto.RegisterType((*UserList)(nil), "auth.UserList")
	proto.RegisterType((*ByAbbrevRequest)(nil), "auth.ByAbbrevRequest")
	proto.RegisterType((*RemoteStoreRequest)(nil), "auth.RemoteStoreRequest")
	proto.RegisterType((*RemoteUserRequest)(nil), "auth.RemoteUserRequest")
	proto.RegisterType((*RemoteUser)(nil), "auth.RemoteUser")
	proto.RegisterType((*RemoteUserDetail)(nil), "auth.RemoteUserDetail")
	proto.RegisterType((*SudoRequest)(nil), "auth.SudoRequest")
	proto.RegisterType((*TokenCompromisedRequest)(nil), "auth.TokenCompromisedRequest")
	proto.RegisterType((*NewToken)(nil), "auth.NewToken")
	proto.RegisterType((*VerifyRequest)(nil), "auth.VerifyRequest")
	proto.RegisterType((*VerifyResponse)(nil), "auth.VerifyResponse")
	proto.RegisterType((*ByIDRequest)(nil), "auth.ByIDRequest")
	proto.RegisterType((*VerifyPasswordResponse)(nil), "auth.VerifyPasswordResponse")
	proto.RegisterType((*CreateUserRequest)(nil), "auth.CreateUserRequest")
	proto.RegisterType((*ByEmailRequest)(nil), "auth.ByEmailRequest")
	proto.RegisterType((*UserEmailAddressList)(nil), "auth.UserEmailAddressList")
	proto.RegisterType((*ListAllGroupsRequest)(nil), "auth.ListAllGroupsRequest")
	proto.RegisterType((*NewPasswordResponse)(nil), "auth.NewPasswordResponse")
	proto.RegisterType((*UserDef)(nil), "auth.UserDef")
	proto.RegisterType((*AddTokenRequest)(nil), "auth.AddTokenRequest")
	proto.RegisterType((*KeyResponse)(nil), "auth.KeyResponse")
	proto.RegisterType((*AuthenticatePasswordRequest)(nil), "auth.AuthenticatePasswordRequest")
	proto.RegisterType((*AuthenticateTokenRequest)(nil), "auth.AuthenticateTokenRequest")
	proto.RegisterType((*UserDetail)(nil), "auth.UserDetail")
	proto.RegisterType((*UserTokens)(nil), "auth.UserTokens")
	proto.RegisterType((*GroupDB)(nil), "auth.GroupDB")
	proto.RegisterType((*EmailVerifyPins)(nil), "auth.EmailVerifyPins")
	proto.RegisterType((*SudoStatus)(nil), "auth.SudoStatus")
	proto.RegisterEnum("auth.TokenType", TokenType_name, TokenType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for AuthManagerService service

type AuthManagerServiceClient interface {
	// very dangerous. updates *any* user.
	// calls to this method are limited to specific services
	ForceUpdatePassword(ctx context.Context, in *ForceUpdatePasswordRequest, opts ...grpc.CallOption) (*common.Void, error)
	// also limited to staff only
	ListGroups(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*GroupList, error)
	// get a user by ID - DEPRECATED
	GetUserByID(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*User, error)
	// get a user by Email - DEPRECATED
	GetUserByEmail(ctx context.Context, in *ByEmailRequest, opts ...grpc.CallOption) (*User, error)
	// get a user by ID
	SignedGetUserByID(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*SignedUser, error)
	// get a user by Email
	SignedGetUserByEmail(ctx context.Context, in *ByEmailRequest, opts ...grpc.CallOption) (*SignedUser, error)
	// create a serviceaccount
	CreateService(ctx context.Context, in *CreateServiceRequest, opts ...grpc.CallOption) (*NewService, error)
	// requires root user manager access - see code
	CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*User, error)
	// requires root user manager access - see code. a "fake" user is used, for example, for the prober. it has an extremly short lifespan (<60 secs) and is severly limited in what it can do (e.g. cannot log in). Also it does not add/modify userids
	CreateFakeUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*User, error)
	// create an email to user to reset password
	ResetPasswordEmail(ctx context.Context, in *ResetRequest, opts ...grpc.CallOption) (*common.Void, error)
	// expire token
	ExpireToken(ctx context.Context, in *ExpireTokenRequest, opts ...grpc.CallOption) (*common.Void, error)
	// reset a users' password (the one whose context this is)
	UpdateMyPassword(ctx context.Context, in *UpdatePasswordRequest, opts ...grpc.CallOption) (*common.Void, error)
	// send an emailverification email
	SendEmailVerify(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*common.Void, error)
	// verify an email verification pin
	VerifyEmail(ctx context.Context, in *VerifyEmailRequest, opts ...grpc.CallOption) (*VerifyEmailResponse, error)
	// get me another token
	GetTokenForMe(ctx context.Context, in *GetTokenRequest, opts ...grpc.CallOption) (*TokenResponse, error)
	// get *me* (my useraccount)
	WhoAmI(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*User, error)
	// if a token was compromised, replace it with a different one
	TokenCompromised(ctx context.Context, in *TokenCompromisedRequest, opts ...grpc.CallOption) (*NewToken, error)
	// temporarily become root. User objects for the current user will include group 'root' for a short while
	Sudo(ctx context.Context, in *SudoRequest, opts ...grpc.CallOption) (*common.Void, error)
	// get a group by id - if user has access to it
	GetGroupByID(ctx context.Context, in *GetGroupRequest, opts ...grpc.CallOption) (*Group, error)
	// if we have just linked some account (e.g. via Google Oauth) we need to store the information. Use this call to do so. (this is obviously privileged and for some services only)
	StoreRemote(ctx context.Context, in *RemoteStoreRequest, opts ...grpc.CallOption) (*common.Void, error)
	// if all we have is a oauth thing (which we stored with StoreOAuth) we can get a user with this
	UserByRemoteToken(ctx context.Context, in *RemoteUserRequest, opts ...grpc.CallOption) (*RemoteUser, error)
	// if we have a user but want its OAuthDetails we can get them with this
	GetMyRemoteDetails(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*RemoteUser, error)
	// expire all (non-permanent) tokens for Me
	LogMeOut(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*User, error)
	// logout some other user (privileged operation)
	LogSomeoneOut(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*User, error)
	// get user by abbreviation
	GetByAbbreviation(ctx context.Context, in *ByAbbrevRequest, opts ...grpc.CallOption) (*User, error)
	// get all users, root only, very privileged call
	GetAllUsers(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*UserList, error)
}

type authManagerServiceClient struct {
	cc *grpc.ClientConn
}

func NewAuthManagerServiceClient(cc *grpc.ClientConn) AuthManagerServiceClient {
	return &authManagerServiceClient{cc}
}

func (c *authManagerServiceClient) ForceUpdatePassword(ctx context.Context, in *ForceUpdatePasswordRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/auth.AuthManagerService/ForceUpdatePassword", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authManagerServiceClient) ListGroups(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*GroupList, error) {
	out := new(GroupList)
	err := grpc.Invoke(ctx, "/auth.AuthManagerService/ListGroups", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authManagerServiceClient) GetUserByID(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := grpc.Invoke(ctx, "/auth.AuthManagerService/GetUserByID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authManagerServiceClient) GetUserByEmail(ctx context.Context, in *ByEmailRequest, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := grpc.Invoke(ctx, "/auth.AuthManagerService/GetUserByEmail", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authManagerServiceClient) SignedGetUserByID(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*SignedUser, error) {
	out := new(SignedUser)
	err := grpc.Invoke(ctx, "/auth.AuthManagerService/SignedGetUserByID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authManagerServiceClient) SignedGetUserByEmail(ctx context.Context, in *ByEmailRequest, opts ...grpc.CallOption) (*SignedUser, error) {
	out := new(SignedUser)
	err := grpc.Invoke(ctx, "/auth.AuthManagerService/SignedGetUserByEmail", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authManagerServiceClient) CreateService(ctx context.Context, in *CreateServiceRequest, opts ...grpc.CallOption) (*NewService, error) {
	out := new(NewService)
	err := grpc.Invoke(ctx, "/auth.AuthManagerService/CreateService", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authManagerServiceClient) CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := grpc.Invoke(ctx, "/auth.AuthManagerService/CreateUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authManagerServiceClient) CreateFakeUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := grpc.Invoke(ctx, "/auth.AuthManagerService/CreateFakeUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authManagerServiceClient) ResetPasswordEmail(ctx context.Context, in *ResetRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/auth.AuthManagerService/ResetPasswordEmail", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authManagerServiceClient) ExpireToken(ctx context.Context, in *ExpireTokenRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/auth.AuthManagerService/ExpireToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authManagerServiceClient) UpdateMyPassword(ctx context.Context, in *UpdatePasswordRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/auth.AuthManagerService/UpdateMyPassword", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authManagerServiceClient) SendEmailVerify(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/auth.AuthManagerService/SendEmailVerify", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authManagerServiceClient) VerifyEmail(ctx context.Context, in *VerifyEmailRequest, opts ...grpc.CallOption) (*VerifyEmailResponse, error) {
	out := new(VerifyEmailResponse)
	err := grpc.Invoke(ctx, "/auth.AuthManagerService/VerifyEmail", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authManagerServiceClient) GetTokenForMe(ctx context.Context, in *GetTokenRequest, opts ...grpc.CallOption) (*TokenResponse, error) {
	out := new(TokenResponse)
	err := grpc.Invoke(ctx, "/auth.AuthManagerService/GetTokenForMe", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authManagerServiceClient) WhoAmI(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := grpc.Invoke(ctx, "/auth.AuthManagerService/WhoAmI", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authManagerServiceClient) TokenCompromised(ctx context.Context, in *TokenCompromisedRequest, opts ...grpc.CallOption) (*NewToken, error) {
	out := new(NewToken)
	err := grpc.Invoke(ctx, "/auth.AuthManagerService/TokenCompromised", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authManagerServiceClient) Sudo(ctx context.Context, in *SudoRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/auth.AuthManagerService/Sudo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authManagerServiceClient) GetGroupByID(ctx context.Context, in *GetGroupRequest, opts ...grpc.CallOption) (*Group, error) {
	out := new(Group)
	err := grpc.Invoke(ctx, "/auth.AuthManagerService/GetGroupByID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authManagerServiceClient) StoreRemote(ctx context.Context, in *RemoteStoreRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/auth.AuthManagerService/StoreRemote", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authManagerServiceClient) UserByRemoteToken(ctx context.Context, in *RemoteUserRequest, opts ...grpc.CallOption) (*RemoteUser, error) {
	out := new(RemoteUser)
	err := grpc.Invoke(ctx, "/auth.AuthManagerService/UserByRemoteToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authManagerServiceClient) GetMyRemoteDetails(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*RemoteUser, error) {
	out := new(RemoteUser)
	err := grpc.Invoke(ctx, "/auth.AuthManagerService/GetMyRemoteDetails", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authManagerServiceClient) LogMeOut(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := grpc.Invoke(ctx, "/auth.AuthManagerService/LogMeOut", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authManagerServiceClient) LogSomeoneOut(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := grpc.Invoke(ctx, "/auth.AuthManagerService/LogSomeoneOut", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authManagerServiceClient) GetByAbbreviation(ctx context.Context, in *ByAbbrevRequest, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := grpc.Invoke(ctx, "/auth.AuthManagerService/GetByAbbreviation", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authManagerServiceClient) GetAllUsers(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*UserList, error) {
	out := new(UserList)
	err := grpc.Invoke(ctx, "/auth.AuthManagerService/GetAllUsers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for AuthManagerService service

type AuthManagerServiceServer interface {
	// very dangerous. updates *any* user.
	// calls to this method are limited to specific services
	ForceUpdatePassword(context.Context, *ForceUpdatePasswordRequest) (*common.Void, error)
	// also limited to staff only
	ListGroups(context.Context, *common.Void) (*GroupList, error)
	// get a user by ID - DEPRECATED
	GetUserByID(context.Context, *ByIDRequest) (*User, error)
	// get a user by Email - DEPRECATED
	GetUserByEmail(context.Context, *ByEmailRequest) (*User, error)
	// get a user by ID
	SignedGetUserByID(context.Context, *ByIDRequest) (*SignedUser, error)
	// get a user by Email
	SignedGetUserByEmail(context.Context, *ByEmailRequest) (*SignedUser, error)
	// create a serviceaccount
	CreateService(context.Context, *CreateServiceRequest) (*NewService, error)
	// requires root user manager access - see code
	CreateUser(context.Context, *CreateUserRequest) (*User, error)
	// requires root user manager access - see code. a "fake" user is used, for example, for the prober. it has an extremly short lifespan (<60 secs) and is severly limited in what it can do (e.g. cannot log in). Also it does not add/modify userids
	CreateFakeUser(context.Context, *CreateUserRequest) (*User, error)
	// create an email to user to reset password
	ResetPasswordEmail(context.Context, *ResetRequest) (*common.Void, error)
	// expire token
	ExpireToken(context.Context, *ExpireTokenRequest) (*common.Void, error)
	// reset a users' password (the one whose context this is)
	UpdateMyPassword(context.Context, *UpdatePasswordRequest) (*common.Void, error)
	// send an emailverification email
	SendEmailVerify(context.Context, *common.Void) (*common.Void, error)
	// verify an email verification pin
	VerifyEmail(context.Context, *VerifyEmailRequest) (*VerifyEmailResponse, error)
	// get me another token
	GetTokenForMe(context.Context, *GetTokenRequest) (*TokenResponse, error)
	// get *me* (my useraccount)
	WhoAmI(context.Context, *common.Void) (*User, error)
	// if a token was compromised, replace it with a different one
	TokenCompromised(context.Context, *TokenCompromisedRequest) (*NewToken, error)
	// temporarily become root. User objects for the current user will include group 'root' for a short while
	Sudo(context.Context, *SudoRequest) (*common.Void, error)
	// get a group by id - if user has access to it
	GetGroupByID(context.Context, *GetGroupRequest) (*Group, error)
	// if we have just linked some account (e.g. via Google Oauth) we need to store the information. Use this call to do so. (this is obviously privileged and for some services only)
	StoreRemote(context.Context, *RemoteStoreRequest) (*common.Void, error)
	// if all we have is a oauth thing (which we stored with StoreOAuth) we can get a user with this
	UserByRemoteToken(context.Context, *RemoteUserRequest) (*RemoteUser, error)
	// if we have a user but want its OAuthDetails we can get them with this
	GetMyRemoteDetails(context.Context, *common.Void) (*RemoteUser, error)
	// expire all (non-permanent) tokens for Me
	LogMeOut(context.Context, *common.Void) (*User, error)
	// logout some other user (privileged operation)
	LogSomeoneOut(context.Context, *ByIDRequest) (*User, error)
	// get user by abbreviation
	GetByAbbreviation(context.Context, *ByAbbrevRequest) (*User, error)
	// get all users, root only, very privileged call
	GetAllUsers(context.Context, *common.Void) (*UserList, error)
}

func RegisterAuthManagerServiceServer(s *grpc.Server, srv AuthManagerServiceServer) {
	s.RegisterService(&_AuthManagerService_serviceDesc, srv)
}

func _AuthManagerService_ForceUpdatePassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ForceUpdatePasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthManagerServiceServer).ForceUpdatePassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthManagerService/ForceUpdatePassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthManagerServiceServer).ForceUpdatePassword(ctx, req.(*ForceUpdatePasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthManagerService_ListGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthManagerServiceServer).ListGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthManagerService/ListGroups",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthManagerServiceServer).ListGroups(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthManagerService_GetUserByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthManagerServiceServer).GetUserByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthManagerService/GetUserByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthManagerServiceServer).GetUserByID(ctx, req.(*ByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthManagerService_GetUserByEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByEmailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthManagerServiceServer).GetUserByEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthManagerService/GetUserByEmail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthManagerServiceServer).GetUserByEmail(ctx, req.(*ByEmailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthManagerService_SignedGetUserByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthManagerServiceServer).SignedGetUserByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthManagerService/SignedGetUserByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthManagerServiceServer).SignedGetUserByID(ctx, req.(*ByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthManagerService_SignedGetUserByEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByEmailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthManagerServiceServer).SignedGetUserByEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthManagerService/SignedGetUserByEmail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthManagerServiceServer).SignedGetUserByEmail(ctx, req.(*ByEmailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthManagerService_CreateService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthManagerServiceServer).CreateService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthManagerService/CreateService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthManagerServiceServer).CreateService(ctx, req.(*CreateServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthManagerService_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthManagerServiceServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthManagerService/CreateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthManagerServiceServer).CreateUser(ctx, req.(*CreateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthManagerService_CreateFakeUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthManagerServiceServer).CreateFakeUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthManagerService/CreateFakeUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthManagerServiceServer).CreateFakeUser(ctx, req.(*CreateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthManagerService_ResetPasswordEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthManagerServiceServer).ResetPasswordEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthManagerService/ResetPasswordEmail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthManagerServiceServer).ResetPasswordEmail(ctx, req.(*ResetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthManagerService_ExpireToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExpireTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthManagerServiceServer).ExpireToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthManagerService/ExpireToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthManagerServiceServer).ExpireToken(ctx, req.(*ExpireTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthManagerService_UpdateMyPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthManagerServiceServer).UpdateMyPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthManagerService/UpdateMyPassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthManagerServiceServer).UpdateMyPassword(ctx, req.(*UpdatePasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthManagerService_SendEmailVerify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthManagerServiceServer).SendEmailVerify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthManagerService/SendEmailVerify",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthManagerServiceServer).SendEmailVerify(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthManagerService_VerifyEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyEmailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthManagerServiceServer).VerifyEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthManagerService/VerifyEmail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthManagerServiceServer).VerifyEmail(ctx, req.(*VerifyEmailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthManagerService_GetTokenForMe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthManagerServiceServer).GetTokenForMe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthManagerService/GetTokenForMe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthManagerServiceServer).GetTokenForMe(ctx, req.(*GetTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthManagerService_WhoAmI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthManagerServiceServer).WhoAmI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthManagerService/WhoAmI",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthManagerServiceServer).WhoAmI(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthManagerService_TokenCompromised_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TokenCompromisedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthManagerServiceServer).TokenCompromised(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthManagerService/TokenCompromised",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthManagerServiceServer).TokenCompromised(ctx, req.(*TokenCompromisedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthManagerService_Sudo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SudoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthManagerServiceServer).Sudo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthManagerService/Sudo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthManagerServiceServer).Sudo(ctx, req.(*SudoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthManagerService_GetGroupByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthManagerServiceServer).GetGroupByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthManagerService/GetGroupByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthManagerServiceServer).GetGroupByID(ctx, req.(*GetGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthManagerService_StoreRemote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoteStoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthManagerServiceServer).StoreRemote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthManagerService/StoreRemote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthManagerServiceServer).StoreRemote(ctx, req.(*RemoteStoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthManagerService_UserByRemoteToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoteUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthManagerServiceServer).UserByRemoteToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthManagerService/UserByRemoteToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthManagerServiceServer).UserByRemoteToken(ctx, req.(*RemoteUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthManagerService_GetMyRemoteDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthManagerServiceServer).GetMyRemoteDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthManagerService/GetMyRemoteDetails",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthManagerServiceServer).GetMyRemoteDetails(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthManagerService_LogMeOut_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthManagerServiceServer).LogMeOut(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthManagerService/LogMeOut",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthManagerServiceServer).LogMeOut(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthManagerService_LogSomeoneOut_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthManagerServiceServer).LogSomeoneOut(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthManagerService/LogSomeoneOut",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthManagerServiceServer).LogSomeoneOut(ctx, req.(*ByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthManagerService_GetByAbbreviation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByAbbrevRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthManagerServiceServer).GetByAbbreviation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthManagerService/GetByAbbreviation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthManagerServiceServer).GetByAbbreviation(ctx, req.(*ByAbbrevRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthManagerService_GetAllUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthManagerServiceServer).GetAllUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthManagerService/GetAllUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthManagerServiceServer).GetAllUsers(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

var _AuthManagerService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "auth.AuthManagerService",
	HandlerType: (*AuthManagerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ForceUpdatePassword",
			Handler:    _AuthManagerService_ForceUpdatePassword_Handler,
		},
		{
			MethodName: "ListGroups",
			Handler:    _AuthManagerService_ListGroups_Handler,
		},
		{
			MethodName: "GetUserByID",
			Handler:    _AuthManagerService_GetUserByID_Handler,
		},
		{
			MethodName: "GetUserByEmail",
			Handler:    _AuthManagerService_GetUserByEmail_Handler,
		},
		{
			MethodName: "SignedGetUserByID",
			Handler:    _AuthManagerService_SignedGetUserByID_Handler,
		},
		{
			MethodName: "SignedGetUserByEmail",
			Handler:    _AuthManagerService_SignedGetUserByEmail_Handler,
		},
		{
			MethodName: "CreateService",
			Handler:    _AuthManagerService_CreateService_Handler,
		},
		{
			MethodName: "CreateUser",
			Handler:    _AuthManagerService_CreateUser_Handler,
		},
		{
			MethodName: "CreateFakeUser",
			Handler:    _AuthManagerService_CreateFakeUser_Handler,
		},
		{
			MethodName: "ResetPasswordEmail",
			Handler:    _AuthManagerService_ResetPasswordEmail_Handler,
		},
		{
			MethodName: "ExpireToken",
			Handler:    _AuthManagerService_ExpireToken_Handler,
		},
		{
			MethodName: "UpdateMyPassword",
			Handler:    _AuthManagerService_UpdateMyPassword_Handler,
		},
		{
			MethodName: "SendEmailVerify",
			Handler:    _AuthManagerService_SendEmailVerify_Handler,
		},
		{
			MethodName: "VerifyEmail",
			Handler:    _AuthManagerService_VerifyEmail_Handler,
		},
		{
			MethodName: "GetTokenForMe",
			Handler:    _AuthManagerService_GetTokenForMe_Handler,
		},
		{
			MethodName: "WhoAmI",
			Handler:    _AuthManagerService_WhoAmI_Handler,
		},
		{
			MethodName: "TokenCompromised",
			Handler:    _AuthManagerService_TokenCompromised_Handler,
		},
		{
			MethodName: "Sudo",
			Handler:    _AuthManagerService_Sudo_Handler,
		},
		{
			MethodName: "GetGroupByID",
			Handler:    _AuthManagerService_GetGroupByID_Handler,
		},
		{
			MethodName: "StoreRemote",
			Handler:    _AuthManagerService_StoreRemote_Handler,
		},
		{
			MethodName: "UserByRemoteToken",
			Handler:    _AuthManagerService_UserByRemoteToken_Handler,
		},
		{
			MethodName: "GetMyRemoteDetails",
			Handler:    _AuthManagerService_GetMyRemoteDetails_Handler,
		},
		{
			MethodName: "LogMeOut",
			Handler:    _AuthManagerService_LogMeOut_Handler,
		},
		{
			MethodName: "LogSomeoneOut",
			Handler:    _AuthManagerService_LogSomeoneOut_Handler,
		},
		{
			MethodName: "GetByAbbreviation",
			Handler:    _AuthManagerService_GetByAbbreviation_Handler,
		},
		{
			MethodName: "GetAllUsers",
			Handler:    _AuthManagerService_GetAllUsers_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protos/golang.conradwood.net/apis/auth/auth.proto",
}

// Client API for AuthenticationService service

type AuthenticationServiceClient interface {
	// DEPRECATED authenticate a user by username/password, return token
	GetByPassword(ctx context.Context, in *AuthenticatePasswordRequest, opts ...grpc.CallOption) (*AuthResponse, error)
	// DEPRECATED authenticate a user by token, return same token
	GetByToken(ctx context.Context, in *AuthenticateTokenRequest, opts ...grpc.CallOption) (*AuthResponse, error)
	// authenticate a user by username/password, return token
	SignedGetByPassword(ctx context.Context, in *AuthenticatePasswordRequest, opts ...grpc.CallOption) (*SignedAuthResponse, error)
	// authenticate a user by token, return same token
	SignedGetByToken(ctx context.Context, in *AuthenticateTokenRequest, opts ...grpc.CallOption) (*SignedAuthResponse, error)
	// get the public signing key
	GetPublicSigningKey(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*KeyResponse, error)
}

type authenticationServiceClient struct {
	cc *grpc.ClientConn
}

func NewAuthenticationServiceClient(cc *grpc.ClientConn) AuthenticationServiceClient {
	return &authenticationServiceClient{cc}
}

func (c *authenticationServiceClient) GetByPassword(ctx context.Context, in *AuthenticatePasswordRequest, opts ...grpc.CallOption) (*AuthResponse, error) {
	out := new(AuthResponse)
	err := grpc.Invoke(ctx, "/auth.AuthenticationService/GetByPassword", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authenticationServiceClient) GetByToken(ctx context.Context, in *AuthenticateTokenRequest, opts ...grpc.CallOption) (*AuthResponse, error) {
	out := new(AuthResponse)
	err := grpc.Invoke(ctx, "/auth.AuthenticationService/GetByToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authenticationServiceClient) SignedGetByPassword(ctx context.Context, in *AuthenticatePasswordRequest, opts ...grpc.CallOption) (*SignedAuthResponse, error) {
	out := new(SignedAuthResponse)
	err := grpc.Invoke(ctx, "/auth.AuthenticationService/SignedGetByPassword", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authenticationServiceClient) SignedGetByToken(ctx context.Context, in *AuthenticateTokenRequest, opts ...grpc.CallOption) (*SignedAuthResponse, error) {
	out := new(SignedAuthResponse)
	err := grpc.Invoke(ctx, "/auth.AuthenticationService/SignedGetByToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authenticationServiceClient) GetPublicSigningKey(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*KeyResponse, error) {
	out := new(KeyResponse)
	err := grpc.Invoke(ctx, "/auth.AuthenticationService/GetPublicSigningKey", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for AuthenticationService service

type AuthenticationServiceServer interface {
	// DEPRECATED authenticate a user by username/password, return token
	GetByPassword(context.Context, *AuthenticatePasswordRequest) (*AuthResponse, error)
	// DEPRECATED authenticate a user by token, return same token
	GetByToken(context.Context, *AuthenticateTokenRequest) (*AuthResponse, error)
	// authenticate a user by username/password, return token
	SignedGetByPassword(context.Context, *AuthenticatePasswordRequest) (*SignedAuthResponse, error)
	// authenticate a user by token, return same token
	SignedGetByToken(context.Context, *AuthenticateTokenRequest) (*SignedAuthResponse, error)
	// get the public signing key
	GetPublicSigningKey(context.Context, *common.Void) (*KeyResponse, error)
}

func RegisterAuthenticationServiceServer(s *grpc.Server, srv AuthenticationServiceServer) {
	s.RegisterService(&_AuthenticationService_serviceDesc, srv)
}

func _AuthenticationService_GetByPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthenticatePasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthenticationServiceServer).GetByPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthenticationService/GetByPassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthenticationServiceServer).GetByPassword(ctx, req.(*AuthenticatePasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthenticationService_GetByToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthenticateTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthenticationServiceServer).GetByToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthenticationService/GetByToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthenticationServiceServer).GetByToken(ctx, req.(*AuthenticateTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthenticationService_SignedGetByPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthenticatePasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthenticationServiceServer).SignedGetByPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthenticationService/SignedGetByPassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthenticationServiceServer).SignedGetByPassword(ctx, req.(*AuthenticatePasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthenticationService_SignedGetByToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthenticateTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthenticationServiceServer).SignedGetByToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthenticationService/SignedGetByToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthenticationServiceServer).SignedGetByToken(ctx, req.(*AuthenticateTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthenticationService_GetPublicSigningKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthenticationServiceServer).GetPublicSigningKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthenticationService/GetPublicSigningKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthenticationServiceServer).GetPublicSigningKey(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

var _AuthenticationService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "auth.AuthenticationService",
	HandlerType: (*AuthenticationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetByPassword",
			Handler:    _AuthenticationService_GetByPassword_Handler,
		},
		{
			MethodName: "GetByToken",
			Handler:    _AuthenticationService_GetByToken_Handler,
		},
		{
			MethodName: "SignedGetByPassword",
			Handler:    _AuthenticationService_SignedGetByPassword_Handler,
		},
		{
			MethodName: "SignedGetByToken",
			Handler:    _AuthenticationService_SignedGetByToken_Handler,
		},
		{
			MethodName: "GetPublicSigningKey",
			Handler:    _AuthenticationService_GetPublicSigningKey_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protos/golang.conradwood.net/apis/auth/auth.proto",
}

func init() { proto.RegisterFile("protos/golang.conradwood.net/apis/auth/auth.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 2098 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xbc, 0x19, 0xcb, 0x72, 0xdb, 0xc8,
	0x31, 0x20, 0x21, 0x89, 0x6a, 0x3e, 0x35, 0xa2, 0x64, 0x84, 0x9b, 0x38, 0xd4, 0xc4, 0xeb, 0x28,
	0xde, 0xac, 0x64, 0x73, 0xd7, 0xae, 0x4d, 0xa5, 0xec, 0x0a, 0x65, 0x92, 0x2a, 0xc6, 0x12, 0xa5,
	0x02, 0x65, 0xed, 0x2d, 0x15, 0x88, 0x18, 0xd1, 0x28, 0x93, 0x00, 0x03, 0x80, 0x52, 0x74, 0xcc,
	0x2d, 0x7f, 0x90, 0x6b, 0xee, 0xc9, 0x21, 0x3f, 0x90, 0x5b, 0x7e, 0x23, 0x5f, 0x92, 0x4b, 0x6a,
	0x1e, 0x00, 0x66, 0x00, 0x8a, 0x94, 0x37, 0x55, 0xbe, 0xd8, 0xe8, 0x9e, 0xee, 0x9e, 0x7e, 0x4f,
	0xb7, 0x08, 0x2f, 0x66, 0xbe, 0x17, 0x7a, 0xc1, 0xe1, 0xd8, 0x9b, 0x58, 0xee, 0xf8, 0x60, 0xe4,
	0xb9, 0xbe, 0x65, 0xdf, 0x7a, 0x9e, 0x7d, 0xe0, 0x92, 0xf0, 0xd0, 0x9a, 0x39, 0xc1, 0xa1, 0x35,
	0x0f, 0x3f, 0xb0, 0x7f, 0x0e, 0x18, 0x2d, 0xd2, 0xe9, 0x77, 0xe3, 0x60, 0x09, 0xc7, 0xc8, 0x9b,
	0x4e, 0x3d, 0x57, 0xfc, 0xc7, 0xb9, 0xf0, 0xdf, 0x34, 0x28, 0xb5, 0xe7, 0xe1, 0x07, 0x93, 0x04,
	0x33, 0xcf, 0x0d, 0x08, 0xaa, 0xc3, 0xda, 0xa5, 0x35, 0x71, 0x6c, 0x43, 0x6b, 0x6a, 0xfb, 0x05,
	0x93, 0x03, 0xe8, 0x09, 0x94, 0xcf, 0xe7, 0x57, 0x13, 0x67, 0x74, 0x4a, 0x82, 0xc0, 0x1a, 0x13,
	0x23, 0xd7, 0xd4, 0xf6, 0x37, 0x4d, 0x15, 0x89, 0x1e, 0x03, 0x9c, 0x78, 0xe3, 0x88, 0x24, 0xcf,
	0x48, 0x24, 0x0c, 0x7a, 0x0c, 0xfa, 0xfb, 0x80, 0xf8, 0x86, 0xde, 0xd4, 0xf6, 0x8b, 0x2d, 0x38,
	0x60, 0xda, 0x53, 0x8c, 0xc9, 0xf0, 0xf4, 0xee, 0x0b, 0xef, 0x23, 0x71, 0x8d, 0x35, 0xc6, 0xca,
	0x01, 0xfc, 0x0f, 0x0d, 0xd0, 0xd0, 0x19, 0xbb, 0xc4, 0xfe, 0x6c, 0x8a, 0x3e, 0x51, 0x14, 0xad,
	0x71, 0x45, 0xb9, 0x0e, 0x2b, 0xd5, 0x7d, 0x03, 0x90, 0x50, 0x22, 0x24, 0x24, 0x51, 0x25, 0x4b,
	0x82, 0xef, 0x27, 0xb0, 0x49, 0x29, 0xac, 0x70, 0xee, 0x73, 0xfd, 0x4a, 0x66, 0x82, 0xc0, 0xff,
	0xc9, 0x73, 0x16, 0x54, 0x81, 0x5c, 0xbf, 0xc3, 0x18, 0x37, 0xcd, 0x5c, 0xbf, 0x43, 0xaf, 0xeb,
	0x4e, 0x2d, 0x67, 0x22, 0x4c, 0xe2, 0x00, 0x15, 0xd6, 0x73, 0xfc, 0x20, 0x1c, 0x58, 0xd3, 0xc8,
	0x92, 0x04, 0x81, 0x1a, 0x50, 0x38, 0xb1, 0xc4, 0xa1, 0xce, 0x0e, 0x63, 0x98, 0x9e, 0x9d, 0x5b,
	0x41, 0x70, 0xeb, 0xf9, 0xb6, 0xb0, 0x20, 0x86, 0xd1, 0xcf, 0x61, 0xfd, 0xd8, 0xf7, 0xe6, 0xb3,
	0xc0, 0x58, 0x6f, 0xe6, 0xf7, 0x8b, 0xad, 0x22, 0x77, 0x01, 0xc3, 0x99, 0xe2, 0x08, 0xed, 0xc2,
	0x7a, 0xfb, 0xea, 0xca, 0x27, 0x37, 0xc6, 0x06, 0x63, 0x17, 0x10, 0xc3, 0x8f, 0x42, 0xe7, 0x86,
	0x18, 0x05, 0x16, 0x1a, 0x01, 0xa1, 0xa7, 0x50, 0x19, 0x12, 0xff, 0xc6, 0x19, 0x91, 0xf6, 0x68,
	0xe4, 0xcd, 0xdd, 0xd0, 0xd8, 0x64, 0xe7, 0x29, 0x2c, 0x8d, 0x21, 0xb3, 0xed, 0x92, 0xf8, 0xce,
	0xb5, 0x43, 0x6c, 0x03, 0x18, 0x99, 0x8a, 0x44, 0xcf, 0xa0, 0x16, 0x3b, 0xed, 0x92, 0xf8, 0x81,
	0xe3, 0xb9, 0x46, 0xb1, 0xa9, 0xed, 0x97, 0xcd, 0x0c, 0x9e, 0x9a, 0x2a, 0x32, 0x28, 0x34, 0x4a,
	0x8c, 0x26, 0x86, 0x51, 0x13, 0x8a, 0x31, 0x7d, 0xbf, 0x63, 0x94, 0x59, 0x3c, 0x64, 0x14, 0xd5,
	0x27, 0x06, 0x7b, 0xf3, 0xc9, 0xc4, 0xa8, 0x30, 0x1a, 0x15, 0x49, 0xad, 0x3b, 0xf3, 0xc7, 0x96,
	0xeb, 0x04, 0x56, 0xe8, 0x78, 0x6e, 0xbf, 0x63, 0x54, 0x99, 0x57, 0x52, 0x58, 0xfc, 0x3d, 0xec,
	0x9c, 0x38, 0xee, 0x47, 0xe6, 0x43, 0xf9, 0x48, 0x8a, 0xb7, 0x1e, 0xc5, 0xfb, 0xcc, 0x1f, 0xf7,
	0x3b, 0x2c, 0xde, 0xba, 0xc9, 0x01, 0x64, 0xc0, 0x06, 0x63, 0xed, 0x77, 0x58, 0xb4, 0x75, 0x33,
	0x02, 0x71, 0x0b, 0x4a, 0x4b, 0xe5, 0x21, 0xd0, 0x59, 0x1e, 0xf0, 0xf4, 0x61, 0xdf, 0xf8, 0x14,
	0xd6, 0x18, 0x7b, 0x26, 0xd9, 0x16, 0x10, 0x53, 0x4f, 0x75, 0x48, 0x30, 0xf2, 0x9d, 0x19, 0x95,
	0x2f, 0x92, 0x4d, 0x46, 0xe1, 0xe7, 0xb0, 0xc9, 0xc4, 0x9d, 0x38, 0x41, 0x28, 0xe5, 0x90, 0x76,
	0x6f, 0x0e, 0xe1, 0x2e, 0x6c, 0xb5, 0x6d, 0xfb, 0xc2, 0xe3, 0x58, 0xf2, 0xc7, 0x39, 0x09, 0x42,
	0x9a, 0x40, 0xb4, 0x02, 0x62, 0x85, 0x04, 0x24, 0xdb, 0xce, 0xf5, 0x8a, 0x6d, 0xff, 0x1d, 0xec,
	0x9a, 0x64, 0xea, 0xdd, 0x90, 0x9e, 0xef, 0x4d, 0xff, 0x4f, 0x59, 0x7f, 0x80, 0x1a, 0xd5, 0x5f,
	0x91, 0x22, 0x51, 0x6b, 0x0a, 0x35, 0x6a, 0x41, 0xbd, 0xef, 0x8e, 0x26, 0x73, 0x9b, 0xf4, 0x5d,
	0x8b, 0xe5, 0x39, 0xbd, 0x20, 0x60, 0x42, 0x0b, 0xe6, 0xc2, 0x33, 0xfc, 0x2d, 0xd4, 0xe8, 0x07,
	0xbd, 0x25, 0x6e, 0x67, 0x4d, 0x58, 0xe3, 0x8c, 0xdc, 0x59, 0x72, 0x73, 0xe4, 0x07, 0xf8, 0xd7,
	0xb0, 0xf3, 0x7e, 0x66, 0x5b, 0x21, 0x89, 0xaa, 0x34, 0x52, 0xae, 0x09, 0xc5, 0x01, 0xb9, 0x8d,
	0x6b, 0x99, 0x2b, 0x28, 0xa3, 0xf0, 0x25, 0xd4, 0xbb, 0x13, 0x72, 0x63, 0x85, 0xb4, 0xc6, 0x48,
	0x10, 0x44, 0x9c, 0x0d, 0x28, 0x08, 0x3b, 0xf8, 0xbd, 0x9b, 0x66, 0x0c, 0x23, 0x0c, 0xa5, 0xce,
	0xdc, 0x67, 0xa9, 0x34, 0x24, 0x23, 0x6e, 0x50, 0xd9, 0x54, 0x70, 0xf8, 0x12, 0x1a, 0x3d, 0xcf,
	0x1f, 0x91, 0xc5, 0x7a, 0xdd, 0xe7, 0xfa, 0x94, 0xbe, 0xb9, 0xac, 0xbe, 0xd7, 0x80, 0xba, 0xb6,
	0x13, 0xb6, 0xdd, 0x3b, 0xe6, 0x80, 0x15, 0xf2, 0x94, 0x16, 0x98, 0x5b, 0xd6, 0x02, 0xf3, 0x6a,
	0x0b, 0xc4, 0xef, 0xa0, 0x4a, 0xef, 0x19, 0x92, 0xc9, 0x75, 0x74, 0x89, 0x22, 0x4c, 0x5b, 0x26,
	0x2c, 0x97, 0x12, 0xf6, 0x16, 0x8a, 0x6f, 0x7d, 0x62, 0x85, 0x84, 0x57, 0x54, 0x54, 0x41, 0xda,
	0xfd, 0x15, 0xa4, 0x67, 0x2b, 0xa8, 0x0f, 0x48, 0x12, 0x12, 0x29, 0xf5, 0x8d, 0x22, 0x9a, 0x89,
	0x2c, 0xb6, 0xb6, 0x78, 0x8a, 0xc8, 0xe4, 0x32, 0x15, 0xfe, 0x0e, 0xb6, 0x15, 0x51, 0x22, 0xd1,
	0xf6, 0x44, 0xc9, 0x0b, 0x29, 0x4a, 0x55, 0xf2, 0x13, 0xbc, 0x07, 0xd5, 0x63, 0xa2, 0x16, 0x40,
	0xaa, 0x3f, 0xe0, 0x97, 0x50, 0x4b, 0x48, 0x1e, 0x2e, 0xf9, 0x3d, 0x3c, 0x62, 0x1f, 0x92, 0xc9,
	0xab, 0x4b, 0x2c, 0xe5, 0xb5, 0x5c, 0xd6, 0x6b, 0x03, 0xa8, 0x73, 0x53, 0xc5, 0x4b, 0x22, 0x55,
	0x86, 0xc0, 0x48, 0xa1, 0x90, 0x51, 0xc9, 0x1b, 0x9e, 0x93, 0xdf, 0xf0, 0x23, 0x80, 0x01, 0xb9,
	0x15, 0x74, 0xf1, 0xd8, 0xa2, 0xad, 0x1a, 0x5b, 0x14, 0x19, 0x4f, 0xa0, 0x64, 0x92, 0x80, 0x84,
	0x91, 0x2e, 0xf1, 0xf3, 0xad, 0x49, 0xcf, 0x37, 0x7e, 0x06, 0xa8, 0xfb, 0xa7, 0x99, 0xe3, 0x13,
	0xc6, 0x24, 0xd1, 0x72, 0x89, 0x9a, 0x2c, 0xf1, 0x29, 0x20, 0xf6, 0xfa, 0xdd, 0x31, 0xd6, 0x88,
	0xb6, 0x06, 0xf9, 0x73, 0x27, 0xa2, 0xa4, 0x9f, 0xf8, 0x05, 0x6c, 0x2b, 0x74, 0x22, 0x3c, 0x0d,
	0x28, 0xc4, 0x2f, 0x2a, 0x9f, 0x99, 0x62, 0x18, 0xbf, 0x64, 0x11, 0x57, 0x74, 0x48, 0xd7, 0x3f,
	0x7f, 0x48, 0xd4, 0xfa, 0x7f, 0x0d, 0x65, 0xc1, 0x23, 0xee, 0xd8, 0x85, 0x75, 0x66, 0xce, 0x1d,
	0x23, 0x2f, 0x9b, 0x02, 0xba, 0xc7, 0x45, 0x2d, 0x28, 0x44, 0x7d, 0x10, 0x3d, 0x55, 0xfb, 0x5f,
	0x76, 0xe6, 0x12, 0x5d, 0xf0, 0x97, 0x50, 0x3d, 0xba, 0xe3, 0x83, 0x86, 0xd4, 0x17, 0xc4, 0x1c,
	0xa2, 0xc9, 0x73, 0x08, 0xfe, 0x8b, 0x06, 0x88, 0xbe, 0x0a, 0x21, 0x19, 0x86, 0x9e, 0x4f, 0x56,
	0xb5, 0x91, 0x06, 0x14, 0xce, 0xe6, 0xbe, 0xac, 0x66, 0x0c, 0x53, 0x67, 0x70, 0x49, 0x82, 0x93,
	0x37, 0x12, 0x05, 0xc7, 0xe6, 0x29, 0xdf, 0xbb, 0x71, 0x6c, 0x31, 0x38, 0xd2, 0x79, 0x4a, 0xc0,
	0xf8, 0x10, 0xb6, 0x12, 0x5a, 0xa9, 0xfb, 0xc6, 0x17, 0x6a, 0xea, 0x85, 0xf8, 0xf7, 0x00, 0x09,
	0xc3, 0xca, 0x0c, 0x7c, 0x0e, 0x1b, 0x1d, 0x12, 0x5a, 0xce, 0x84, 0xb6, 0x69, 0xea, 0xbe, 0x5d,
	0x4e, 0x92, 0x88, 0xe0, 0xc7, 0x66, 0x44, 0x86, 0xff, 0xa9, 0x41, 0x2d, 0x7d, 0x9a, 0x99, 0x18,
	0x12, 0x4f, 0xe5, 0xd2, 0x9e, 0x8a, 0x2d, 0xcd, 0xab, 0x96, 0x2a, 0x46, 0xe9, 0x29, 0x2f, 0x1a,
	0xb0, 0xc1, 0xcb, 0x94, 0x0f, 0x9c, 0x65, 0x33, 0x02, 0x33, 0xfe, 0x5d, 0xcf, 0xfa, 0x17, 0x7f,
	0x09, 0xc5, 0xe1, 0xdc, 0xf6, 0x56, 0x84, 0x11, 0x1f, 0xc2, 0x23, 0x76, 0xdb, 0x5b, 0x6f, 0x3a,
	0xf3, 0xbd, 0xa9, 0x13, 0x10, 0x7b, 0x79, 0x59, 0x35, 0xa1, 0x30, 0x20, 0xb7, 0x5c, 0xc3, 0xc5,
	0x14, 0x5f, 0x42, 0x99, 0x17, 0xd4, 0x72, 0x41, 0x3d, 0xa8, 0x44, 0x64, 0x4b, 0x77, 0x94, 0x28,
	0x9a, 0xb9, 0xc5, 0xd1, 0xa4, 0x86, 0x1e, 0xdd, 0xf5, 0x3b, 0xab, 0x0c, 0x1d, 0xc0, 0x2e, 0xbf,
	0x2e, 0x79, 0x77, 0xc5, 0xb5, 0x3f, 0xac, 0x61, 0xfd, 0x4b, 0x83, 0x2d, 0x1e, 0x0f, 0x39, 0x49,
	0x17, 0xb6, 0xad, 0x1f, 0xfe, 0xe4, 0x2a, 0x5b, 0x87, 0x9e, 0xda, 0x3a, 0x92, 0x42, 0x5e, 0x53,
	0x16, 0x8a, 0xcc, 0x42, 0xb0, 0xbe, 0x60, 0x21, 0xc0, 0x4f, 0xa1, 0x72, 0xa4, 0xb6, 0xc6, 0xc5,
	0x2d, 0xf7, 0x00, 0xea, 0xd4, 0x40, 0x06, 0xb4, 0x6d, 0xdb, 0x27, 0x41, 0xc0, 0x3a, 0x10, 0xed,
	0x5d, 0x53, 0x56, 0x43, 0x7c, 0x14, 0x12, 0x10, 0xde, 0x85, 0x3a, 0x3d, 0x6f, 0x4f, 0x26, 0x7c,
	0x66, 0x15, 0xd2, 0x69, 0x9b, 0x95, 0x66, 0x16, 0xb9, 0xcd, 0xa6, 0x46, 0xb1, 0x18, 0xc6, 0x7b,
	0xb0, 0xc1, 0xcb, 0xed, 0xfa, 0xde, 0xa8, 0x3a, 0x50, 0x65, 0x03, 0xb1, 0xd4, 0x89, 0xef, 0x6b,
	0x58, 0x0b, 0xc3, 0x88, 0xf6, 0xa1, 0xca, 0x9b, 0xee, 0x85, 0x33, 0x25, 0x41, 0x68, 0x4d, 0x67,
	0x2c, 0x06, 0x65, 0x33, 0x8d, 0xc6, 0xaf, 0xa1, 0xf8, 0x8e, 0x24, 0xc9, 0x5a, 0x83, 0xfc, 0x3b,
	0x72, 0x27, 0x36, 0x55, 0xfa, 0x49, 0xa3, 0xfc, 0x76, 0xe2, 0xcd, 0x6d, 0x39, 0xca, 0x31, 0x02,
	0x9f, 0xc1, 0x17, 0x74, 0x21, 0x27, 0x6e, 0xe8, 0x8c, 0x16, 0x4c, 0x7f, 0x8b, 0x13, 0x47, 0xf6,
	0x4e, 0x2e, 0xe5, 0x9d, 0xe7, 0x60, 0xc8, 0x02, 0x1f, 0xf0, 0x22, 0xfe, 0x5b, 0x03, 0x58, 0xd2,
	0xbf, 0x3e, 0xe7, 0xc6, 0x5c, 0x87, 0xb5, 0xb6, 0x3d, 0x75, 0x5c, 0x91, 0x9b, 0x1c, 0xc8, 0x66,
	0xee, 0x06, 0x0b, 0x45, 0x2a, 0x73, 0xff, 0x2e, 0xcc, 0x60, 0x46, 0x05, 0x2b, 0xda, 0xb0, 0x9e,
	0x8d, 0x7f, 0x5e, 0x8e, 0xbf, 0xd4, 0x64, 0x75, 0xb5, 0xc9, 0x26, 0x8f, 0xf3, 0x9a, 0xf2, 0x38,
	0x7f, 0x0d, 0x9b, 0x8c, 0xf5, 0xe2, 0x6e, 0x46, 0x98, 0xfa, 0x95, 0x56, 0x95, 0xf7, 0x8c, 0x18,
	0x6d, 0x26, 0x14, 0xf8, 0x4c, 0x0c, 0x6a, 0x9d, 0xa3, 0x87, 0xac, 0x98, 0x0f, 0xd8, 0x1a, 0xff,
	0xac, 0x41, 0x35, 0x71, 0xc8, 0xdd, 0xb9, 0xf3, 0x09, 0x3e, 0x10, 0xd3, 0x4f, 0x3e, 0x9e, 0x7e,
	0xd2, 0xf6, 0xeb, 0x89, 0xfd, 0x0d, 0x28, 0xd0, 0xf5, 0x67, 0x16, 0xbd, 0x3f, 0xba, 0x19, 0xc3,
	0xf8, 0x1a, 0x80, 0x3e, 0x2e, 0xc3, 0xd0, 0x0a, 0xe7, 0x0f, 0xbf, 0x3d, 0xb5, 0x8c, 0x4b, 0x33,
	0x6b, 0xe2, 0x6b, 0x5d, 0xf6, 0xf5, 0xb3, 0x57, 0x92, 0xaf, 0x51, 0x19, 0x36, 0xdf, 0x0f, 0x3a,
	0xdd, 0x5e, 0x7f, 0xd0, 0xed, 0xd4, 0x7e, 0x44, 0xc1, 0xf3, 0xae, 0x79, 0xda, 0x1e, 0x74, 0x07,
	0x17, 0x35, 0x0d, 0x15, 0x61, 0x63, 0xd8, 0x1d, 0x0e, 0xfb, 0x67, 0x83, 0x5a, 0xae, 0xf5, 0xd7,
	0x22, 0x20, 0x5a, 0x1c, 0xa7, 0x96, 0x6b, 0x8d, 0x89, 0x1f, 0x8d, 0xa6, 0x5d, 0xd8, 0x5e, 0xb0,
	0x80, 0xa1, 0x26, 0x0f, 0xdf, 0xfd, 0xbb, 0x59, 0xa3, 0x74, 0x20, 0xfe, 0x0c, 0x78, 0xe9, 0x39,
	0x36, 0xfa, 0x0a, 0x20, 0x5e, 0x79, 0x03, 0xa4, 0x9c, 0x35, 0xaa, 0xd2, 0x18, 0xcf, 0xfa, 0xe4,
	0xaf, 0xa0, 0x78, 0x4c, 0x42, 0xea, 0x01, 0xfa, 0x4a, 0x21, 0xb1, 0x86, 0x48, 0x2f, 0x56, 0x43,
	0x7a, 0x71, 0x50, 0x0b, 0x2a, 0x31, 0x35, 0xaf, 0xbf, 0x7a, 0xc4, 0x20, 0xf7, 0x6a, 0x85, 0xe7,
	0x3b, 0xd8, 0xe2, 0x83, 0xdf, 0x8a, 0x7b, 0x32, 0x43, 0x22, 0x7a, 0x03, 0xf5, 0x14, 0xe7, 0xb2,
	0x3b, 0xb3, 0xfc, 0xaf, 0xa1, 0xac, 0x2c, 0x12, 0xa8, 0x21, 0x2f, 0x59, 0xea, 0x76, 0x11, 0xb1,
	0x4b, 0x9b, 0xc2, 0x0b, 0x80, 0xe4, 0x05, 0x45, 0x8f, 0x64, 0x5e, 0xe9, 0x4d, 0x55, 0x6c, 0x7d,
	0x09, 0x15, 0x4e, 0xd0, 0xb3, 0x3e, 0x7e, 0x02, 0xdb, 0x2b, 0x3a, 0xda, 0x06, 0x24, 0x8c, 0xe2,
	0xca, 0xcd, 0x44, 0xd1, 0xd8, 0x97, 0xec, 0x1d, 0xa9, 0x48, 0xbf, 0x84, 0xa2, 0xb4, 0x6f, 0x20,
	0x83, 0x33, 0x64, 0x57, 0x90, 0x14, 0xdb, 0x6b, 0xa8, 0xf1, 0x3c, 0x3a, 0x8d, 0xa7, 0x0d, 0xf4,
	0x85, 0x50, 0xe7, 0x01, 0xf9, 0xf5, 0x35, 0x54, 0x87, 0xc4, 0xb5, 0xa5, 0x22, 0x4f, 0x25, 0x99,
	0x4a, 0x7e, 0x04, 0x45, 0x69, 0x81, 0x89, 0x94, 0xcc, 0xee, 0x3e, 0x8d, 0x1f, 0x2f, 0x38, 0x11,
	0xaf, 0xd9, 0x6f, 0xa0, 0x1c, 0x6d, 0x34, 0x3d, 0xcf, 0x3f, 0x25, 0x68, 0x47, 0xe4, 0xb1, 0xba,
	0xe6, 0x34, 0xb6, 0xa5, 0x4e, 0x17, 0x33, 0x63, 0x58, 0xff, 0xfe, 0x83, 0xd7, 0x9e, 0xf6, 0x53,
	0x6a, 0xca, 0x11, 0x68, 0x43, 0x2d, 0x3d, 0x67, 0xa2, 0x9f, 0x4a, 0xc2, 0xb2, 0xf3, 0x67, 0xa3,
	0x12, 0x27, 0x0c, 0xf7, 0xfe, 0x2f, 0x40, 0xa7, 0x4d, 0x27, 0x4a, 0x6d, 0x69, 0xba, 0x4d, 0x39,
	0xa4, 0x05, 0xa5, 0x68, 0xdb, 0x66, 0xb5, 0x90, 0xd8, 0x22, 0x2f, 0xe9, 0x0d, 0x79, 0xe3, 0xa6,
	0x91, 0x16, 0x6b, 0x0f, 0x9d, 0xa1, 0x23, 0x27, 0x66, 0xf7, 0xa1, 0xd4, 0x55, 0x6f, 0x60, 0x8b,
	0x17, 0x0e, 0xa7, 0xe4, 0x8a, 0x3e, 0x4a, 0xaf, 0x13, 0xa9, 0x12, 0x90, 0x56, 0x95, 0x6f, 0x01,
	0x1d, 0x93, 0xf0, 0x54, 0xb0, 0x8b, 0x75, 0x23, 0xe5, 0xc6, 0x2c, 0xd7, 0x13, 0x28, 0xb0, 0x3f,
	0xbf, 0x9f, 0xcd, 0xc3, 0x25, 0x2e, 0x3f, 0x80, 0xf2, 0x89, 0x37, 0x1e, 0x7a, 0x53, 0xe2, 0xb9,
	0x8c, 0x74, 0x45, 0xef, 0x79, 0x05, 0x5b, 0xc7, 0x24, 0x8c, 0xd6, 0x45, 0x87, 0xff, 0x59, 0x74,
	0x27, 0xe2, 0x51, 0x96, 0x48, 0x85, 0xef, 0x2b, 0xd6, 0xe1, 0xda, 0x93, 0x09, 0x5b, 0x39, 0x53,
	0x0a, 0x55, 0x12, 0x42, 0xda, 0x0e, 0x5b, 0xff, 0xcd, 0xc1, 0x8e, 0x34, 0xb6, 0xb0, 0xd5, 0x98,
	0x77, 0x83, 0x1e, 0x4b, 0xc1, 0xa3, 0xa4, 0x62, 0xf6, 0x38, 0xeb, 0x92, 0xa9, 0xa9, 0x81, 0x12,
	0x92, 0x38, 0x1b, 0x7f, 0x0b, 0xc0, 0xe4, 0xf0, 0x58, 0x3c, 0xce, 0x0a, 0x51, 0x12, 0x7a, 0x91,
	0x04, 0x13, 0xb6, 0xe3, 0xb6, 0xf8, 0x69, 0xfa, 0x18, 0x72, 0x8b, 0x54, 0x64, 0x9e, 0xf0, 0xbf,
	0xbf, 0x0b, 0x99, 0x0f, 0xd3, 0xed, 0x7e, 0x69, 0xaf, 0x60, 0xfb, 0x98, 0x84, 0xfc, 0x57, 0x1a,
	0x7a, 0xec, 0xb8, 0x63, 0x3a, 0x81, 0xaa, 0xae, 0x17, 0xe1, 0x96, 0x86, 0xd6, 0xa3, 0x3d, 0xf8,
	0x99, 0x4b, 0x42, 0xf9, 0xe7, 0x2e, 0xf1, 0x03, 0x98, 0x35, 0x73, 0x02, 0x46, 0x7e, 0xb5, 0xce,
	0x7e, 0xe9, 0xfa, 0xe6, 0x7f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x4c, 0x80, 0x31, 0x01, 0x54, 0x1b,
	0x00, 0x00,
}
