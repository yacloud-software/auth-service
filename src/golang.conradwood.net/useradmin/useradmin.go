package main

import (
	"flag"
	"fmt"
	"golang.conradwood.net/apis/auth"
	"golang.conradwood.net/apis/common"
	au "golang.conradwood.net/go-easyops/auth"
	"golang.conradwood.net/go-easyops/authremote"
	cm "golang.conradwood.net/go-easyops/common"
	"golang.conradwood.net/go-easyops/utils"
	"os"
)

const (
	keyfile = "/tmp/authkey.pub"
)

var (
	am             auth.AuthManagerServiceClient
	email          = flag.String("email", "", "email address of user to operate on")
	resetemail     = flag.Bool("reset_email", false, "send reset email to user [needs email]")
	resetpw        = flag.Bool("reset_password", false, "reset password of user")
	newpw          = flag.String("newpw", "", "new password (for reset_password)")
	show           = flag.Bool("show", false, "show details about a user")
	create_service = flag.Bool("create_service", false, "create service (needs -servicename)")
	create_user    = flag.Bool("create_user", false, "create user (needs -servicename)")
	abbrev         = flag.String("abbrev", "", "abbreviation of user")
	firstname      = flag.String("firstname", "", "first name of user")
	lastname       = flag.String("lastname", "", "last name of user")
	sname          = flag.String("servicename", "", "name of service to create")
	ntoken         = flag.String("new_token", "", "if set, new objects will be created with this token instead of an autogenerated one")
	savekey        = flag.Bool("save_key", false, "save public signing key to "+keyfile)
	logout         = flag.Bool("logout", false, "logout sessions")
	list_all       = flag.Bool("list_all", false, "list all users")
)

func main() {
	flag.Parse()
	am = authremote.GetAuthManagerClient()
	if *logout {
		Logout()
		os.Exit(0)
	}
	if *savekey {
		k, err := authremote.GetAuthClient().GetPublicSigningKey(authremote.Context(), &common.Void{})
		utils.Bail("Failed to get key", err)
		err = utils.WriteFile(keyfile, k.Key)
		utils.Bail("Failed to save file", err)
		fmt.Printf("Saved to file %s\nDone.\n", keyfile)
		os.Exit(0)
	}
	if *list_all {
		ListAll()
	}
	if *resetemail {
		ResetEmailPassword()
	}
	if *resetpw {
		ResetPassword()
	}
	if *create_service {
		CreateService()
	}
	if *create_user {
		CreateUser()
	}

	if *show {
		ShowUser()
	}
	fmt.Printf("Done\n")
}

func CreateService() {
	ctx := authremote.Context()
	res, err := am.CreateService(ctx, &auth.CreateServiceRequest{ServiceName: *sname, Token: *ntoken})
	utils.Bail("failed to create service", err)
	displayUser(res.User)
	fmt.Printf("Servicetoken: %s\n", res.Token)
}
func CreateUser() {
	var u *auth.User
	var err error
	ctx := authremote.Context()
	u, err = am.GetUserByEmail(ctx, &auth.ByEmailRequest{Email: *email})
	if err != nil {
		cur := &auth.CreateUserRequest{
			Password:      *newpw,
			FirstName:     *firstname,
			LastName:      *lastname,
			Abbrev:        *abbrev,
			Email:         *email,
			EmailVerified: true,
		}
		u, err = am.CreateUser(ctx, cur)
	}
	utils.Bail("failed to create user", err)
	displayUser(u)
	fmt.Printf("Sending reset password email to %s\n", u.Email)
	_, err = am.ResetPasswordEmail(ctx, &auth.ResetRequest{Email: u.Email})
	utils.Bail(fmt.Sprintf("Failed to send an email to %s", u.Email), err)
	fmt.Printf("Reset password email sent to %s\n", u.Email)
}

func ResetPassword() {
	ctx := authremote.Context()
	u, err := am.GetUserByEmail(ctx, &auth.ByEmailRequest{Email: *email})
	utils.Bail("failed to lookup by email", err)
	displayUser(u)
	_, err = am.ForceUpdatePassword(ctx, &auth.ForceUpdatePasswordRequest{UserID: u.ID, NewPassword: *newpw})
	utils.Bail("failed to set password", err)
}

func ShowUser() {
	ctx := authremote.Context()
	u, err := am.GetUserByEmail(ctx, &auth.ByEmailRequest{Email: *email})
	utils.Bail("failed to lookup by email", err)
	displayUser(u)
}

func displayUser(user *auth.User) {
	isact := "Active"
	if !user.Active {
		isact = "Inactive"
	}
	isservice := "UserAccount"
	if user.ServiceAccount {
		isservice = "ServiceAccount"
	}
	ev := ""
	if !user.EmailVerified {
		ev = " [ NOT YET VERIFIED ]"
	}
	fmt.Printf("#%s %s\n", user.ID, user.Abbrev)
	fmt.Printf("   %s %s\n", user.FirstName, user.LastName)
	fmt.Printf("   %s%s\n", user.Email, ev)
	fmt.Printf("   %s %s\n", isact, isservice)
	if user.Password != "" {
		fmt.Printf("   Password: \"%s\"\n", user.Password)
	}
	fmt.Printf("   Member of %d groups:\n", len(user.Groups))
	for i, g := range user.Groups {
		fmt.Printf("     %d. #%s (%s)\n", (i + 1), g.ID, g.Name)
	}
}
func ResetEmailPassword() {
	_, err := am.ResetPasswordEmail(authremote.Context(), &auth.ResetRequest{Email: *email})
	utils.Bail("Failed to reset password", err)
	fmt.Printf("send email to %s (if exists in database)\n", *email)

}
func Logout() {
	userid := ""
	// find userid to operate on
	if *email != "" {
		u, err := am.GetUserByEmail(authremote.Context(), &auth.ByEmailRequest{Email: *email})
		utils.Bail("failed to get user by email", err)
		userid = u.ID
	}

	// log out
	if userid == "" {
		u, err := am.LogMeOut(authremote.Context(), &common.Void{})
		utils.Bail("failed to log out", err)
		fmt.Printf("User %s logged out.\n", au.Description(u))
		return
	}
	u, err := am.LogSomeoneOut(authremote.Context(), &auth.ByIDRequest{UserID: userid})
	utils.Bail("failed to log out someone", err)
	fmt.Printf("User %s logged out\n", au.Description(u))
}
func ListAll() {
	ctx := authremote.Context()
	ul, err := am.GetAllUsers(ctx, &common.Void{})
	utils.Bail("failed to get users", err)
	t := utils.Table{}
	t.AddHeaders("ID", "Email", "Abbrev")
	for _, u := range ul.Users {
		ux := cm.VerifySignedUser(u)
		t.AddString(ux.ID)
		t.AddString(ux.Email)
		t.AddString(ux.Abbrev)
		t.NewRow()
	}
	fmt.Println(t.ToPrettyString())
}
